/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,

 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AbortException = exports.AnnotationEditorParamsType = exports.AnnotationEditorType = exports.AnnotationFlag = exports.AnnotationMode = exports.AnnotationReplyType = exports.AnnotationType = exports.CMapCompressionType = exports.DEFAULT_FONT_SIZE = exports.DEFAULT_USER_FONT_SIZE = exports.DocumentInitParameters = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.FontType = exports.ImageKind = exports.Intent = exports.InvalidPDFException = exports.MissingPDFException = exports.NativeImageDecoding = exports.OPS = exports.PasswordResponses = exports.PDFDataRangeTransport = exports.PDFWorker = exports.PermissionFlag = exports.PostMessageKind = exports.ProgressBar = exports.RenderingCancelledException = exports.RenderingIntent = exports.SVGGraphics = exports.UnexpectedResponseException = exports.Util = exports.VerbosityLevel = exports.XfaLayer = exports.build = exports.createPromiseCapability = exports.createValidAbsoluteUrl = exports.getFilenameFromUrl = exports.getVerbosityLevel = exports.isNodeJS = exports.isSameOrigin = exports.isWorker = exports.loadScript = exports.noContextMenu = exports.normalizeAppearanceData = exports.normalizeURL = exports.parseQueryString = exports.setVerbosityLevel = exports.shadow = exports.warn = void 0;
exports.apiPageLayoutToViewerModes = apiPageLayoutToViewerModes;
exports.apiPageModeToViewerModes = apiPageModeToViewerModes;
exports.approximateFraction = approximateFraction;
exports.base64ToBytes = base64ToBytes;
exports.bytesToBase64 = bytesToBase64;
exports.calculateTransform = calculateTransform;
exports.clearPrimitiveCaches = clearPrimitiveCaches;
exports.cloneObj = cloneObj;
exports.combineUrl = combineUrl;
exports.createObjectURL = createObjectURL;
exports.createPageGetViewport = createPageGetViewport;
exports.createPromiseAllWhile = createPromiseAllWhile;
exports.createSuperscript = createSuperscript;
exports.decodeSentences = decodeSentences;
exports.getModificationDate = getModificationDate;
exports.getOwnerPassword = getOwnerPassword;
exports.getUserPassword = getUserPassword;
exports.getXfaPageViewport = getXfaPageViewport;
exports.getZlib = getZlib;
exports.integerToBytes = integerToBytes;
exports.isLittleEndian = isLittleEndian;
exports.isObject = isObject;
exports.isPdfFile = isPdfFile;
exports.isValidFetchUrl = isValidFetchUrl;
exports.numberToBytes = numberToBytes;
exports.numberToHex = numberToHex;
exports.objectSize = objectSize;
exports.parseDestArray = parseDestArray;
exports.postMessageTransfers = postMessageTransfers;
exports.removeNullCharacters = removeNullCharacters;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.transform = transform;
exports.transformBox = transformBox;
exports.validateRange = validateRange;
exports.validateUrl = validateUrl;
exports.verifyFirstPageCoversTheRange = verifyFirstPageCoversTheRange;
exports.viewerCompatibilityParams = exports.isViewerLoading = exports.addLinkAttributes = exports.isSpecialCssProperty = exports.getDisplacement = exports.getScaleFactor = exports.getPageSizeInches = exports.finishAsyncOperation = exports.dispatchGlobalEvent = exports.apiParameters = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
var AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
exports.AnnotationMode = AnnotationMode;
var AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26,
  RICHMEDIA: 27
};
exports.AnnotationType = AnnotationType;
var AnnotationReplyType = {
  REPLY: 1,
  GROUP: 2
};
exports.AnnotationReplyType = AnnotationReplyType;
var AnnotationFlag = {
  INVISIBLE: 1,
  HIDDEN: 2,
  PRINT: 4,
  NOZOOM: 8,
  NOROTATE: 16,
  NOVIEW: 32,
  READONLY: 64,
  LOCKED: 128,
  TOGGLENOVIEW: 256,
  LOCKEDCONTENTS: 512
};
exports.AnnotationFlag = AnnotationFlag;
var AnnotationEditorType = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  INK: 15
};
exports.AnnotationEditorType = AnnotationEditorType;
var AnnotationEditorParamsType = {
  FREETEXT_SIZE: 1,
  FREETEXT_COLOR: 2,
  INK_COLOR: 3,
  INK_THICKNESS: 4,
  INK_OPACITY: 5
};
exports.AnnotationEditorParamsType = AnnotationEditorParamsType;
var CMapCompressionType = {
  NONE: 0,
  PREDEFINED: 1,
  BINARY: 2
};
exports.CMapCompressionType = CMapCompressionType;
var DocumentInitParameters = null;
exports.DocumentInitParameters = DocumentInitParameters;
var FeatureTest = {
  PRINTING: 1,
  IMAGE_DECODING: 2,
  OFFSCREEN_CANVAS: 4
};
exports.FeatureTest = FeatureTest;
var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};
exports.FontType = FontType;
var Intent = {
  DISPLAY: 1,
  PRINT: 2
};
exports.Intent = Intent;
var NativeImageDecoding = {
  NONE: 0,
  DECODE: 1,
  DISPLAY: 2
};
exports.NativeImageDecoding = NativeImageDecoding;
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
var PermissionFlag = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE_DOCUMENT: 1024,
  PRINT_HIGH_QUALITY: 2048
};
exports.PermissionFlag = PermissionFlag;
var PostMessageKind = {
  WORKER_PRINT: 1
};
exports.PostMessageKind = PostMessageKind;
var RenderingIntent = {
  ABSOLUTE_COLORIMETRIC: 1,
  PERCEPTUAL: 2,
  RELATIVE_COLORIMETRIC: 3,
  SATURATION: 4
};
exports.RenderingIntent = RenderingIntent;
var VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
var apiParameters = Object.create(null);
exports.apiParameters = apiParameters;
if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("PRODUCTION")) {
  Object.defineProperty(apiParameters, "experimentalExtraFeatures", {
    value: false,
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(apiParameters, "maxCanvasPixels", {
    value: 16777216,
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(apiParameters, "pageColors", {
    value: null,
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(apiParameters, "pdfBug", {
    value: false,
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(apiParameters, "renderingIntent", {
    value: "display",
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(apiParameters, "enableXfa", {
    value: false,
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(apiParameters, "useSystemFonts", {
    value: false,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
var viewerCompatibilityParams = Object.freeze({
  disableCreateObjectURL: false,
  disableFontFace: false,
  disableRange: false,
  disableStream: false
});
exports.viewerCompatibilityParams = viewerCompatibilityParams;
var DEFAULT_FONT_SIZE = -1;
exports.DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE;
var DEFAULT_USER_FONT_SIZE = 12;
exports.DEFAULT_USER_FONT_SIZE = DEFAULT_USER_FONT_SIZE;
var build = "4.0.379";
exports.build = build;
var isNodeJS = function isNodeJSClosure() {
  return typeof PDFJSDev !== "undefined" && PDFJSDev.test("NODE") || typeof process === "object" && process + "" === "[object process]" && !process.versions["electron"] && !process.versions["nw"];
}();
exports.isNodeJS = isNodeJS;
var isSameOrigin = function isSameOriginClosure(url, baseUrl) {
  try {
    return new URL(url, baseUrl).origin === baseUrl.origin;
  } catch (ex) {
    return false;
  }
};
exports.isSameOrigin = isSameOrigin;
var isSpecialCssProperty = function isSpecialCssPropertyClosure() {
  var prefixes = ["-webkit-", "-moz-", "-o-"];
  var properties = ["appearance", "border-image", "border-radius", "box-shadow", "box-sizing", "font-feature-settings", "text-size-adjust", "transform", "transition"];
  var specialProperties = new Set();
  for (var _i = 0, _properties = properties; _i < _properties.length; _i++) {
    var property = _properties[_i];
    specialProperties.add(property);
    for (var _i2 = 0, _prefixes = prefixes; _i2 < _prefixes.length; _i2++) {
      var prefix = _prefixes[_i2];
      specialProperties.add(prefix + property);
    }
  }
  return function (property) {
    return specialProperties.has(property);
  };
}();
exports.isSpecialCssProperty = isSpecialCssProperty;
var isViewerLoading = false;
exports.isViewerLoading = isViewerLoading;
var isWorker = function isWorkerClosure() {
  return typeof PDFJSDev !== "undefined" && PDFJSDev.test("WORKER") || typeof window === "undefined" && typeof self !== "undefined" && typeof importScripts === "function";
}();
exports.isWorker = isWorker;
var loadScript = function loadScriptClosure(src) {
  return new Promise(function (resolve, reject) {
    var script = document.createElement("script");
    script.src = src;
    script.onload = resolve;
    script.onerror = function () {
      reject(new Error("Cannot load script at: ".concat(src)));
    };
    (document.head || document.documentElement).appendChild(script);
  });
};
exports.loadScript = loadScript;
function clearPrimitiveCaches() {
  var a = new Uint8Array(1);
  var b = new Uint8Array(2);
  var c = new Uint8Array(3);
  var d = new Uint8Array(4);
  var e = new Uint8Array(5);
  var f = new Uint8Array(6);
  a[0] = 0;
  b[0] = 0;
  b[1] = 0;
  c[0] = 0;
  c[1] = 0;
  c[2] = 0;
  d[0] = 0;
  d[1] = 0;
  d[2] = 0;
  d[3] = 0;
  e[0] = 0;
  e[1] = 0;
  e[2] = 0;
  e[3] = 0;
  e[4] = 0;
  f[0] = 0;
  f[1] = 0;
  f[2] = 0;
  f[3] = 0;
  f[4] = 0;
  f[5] = 0;
}
function getXfaPageViewport(xfaPage, _ref) {
  var scale = _ref.scale,
    rotation = _ref.rotation;
  var viewport = xfaPage.page.getViewport({
    scale: scale,
    rotation: rotation
  });
  if (xfaPage.width > 0 && xfaPage.height > 0) {
    var xfaOnlyViewport = xfaPage.page.getViewport({
      scale: scale,
      rotation: 0
    });
    var mat = xfaOnlyViewport.transform;
    var transform = [mat[0], mat[1], mat[2], mat[3], 0, 0];
    var WRITING_MODE_ROTATION = {
      lr_tb: 0,
      rl_tb: 0,
      tb_rl: 90
    };
    var wmr = WRITING_MODE_ROTATION[xfaPage.attributes.writingMode];
    var newRotation = (rotation + wmr) % 360;
    var tr = viewport.transform;
    var xfaWidth = xfaPage.width * scale;
    var xfaHeight = xfaPage.height * scale;
    switch (newRotation) {
      case 90:
        transform = [0, mat[0], -mat[3], 0, tr[4], tr[5] - xfaHeight];
        break;
      case 180:
        transform = [-mat[0], 0, 0, -mat[3], tr[4], tr[5]];
        break;
      case 270:
        transform = [0, -mat[0], mat[3], 0, tr[4] - xfaWidth, tr[5]];
        break;
    }
    viewport = viewport.clone({
      transform: transform
    });
  }
  return viewport;
}
var _verbosity = VerbosityLevel.WARNINGS;
function getVerbosityLevel() {
  return _verbosity;
}
function setVerbosityLevel(level) {
  if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("READONLY")) {
    return;
  }
  if (!Object.values(VerbosityLevel).includes(level)) {
    throw new Error("Invalid verbosity level.");
  }
  _verbosity = level;
}
function warn(msg) {
  if (_verbosity >= VerbosityLevel.WARNINGS) {
    console.warn(msg);
  }
}
function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value: value,
    enumerable: true,
    configurable: true,
    writable: false
  });
}
function getPageSizeInches(_ref2) {
  var view = _ref2.view,
    userUnit = _ref2.userUnit,
    rotate = _ref2.rotate;
  var _view = view,
    x1 = _view[0],
    y1 = _view[1],
    x2 = _view[2],
    y2 = _view[3];
  if ((rotate || 0) % 180 !== 0) {
    [x1, y1, x2, y2] = [y1, x1, y2, x2];
  }
  return {
    width: Math.abs(x2 - x1) / 72 * userUnit,
    height: Math.abs(y2 - y1) / 72 * userUnit
  };
}
var Util = function () {
  function Util() {
    _classCallCheck(this, Util);
  }
  _createClass(Util, null, [{
    key: "makeCssVar",
    value: function makeCssVar(name) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return "--".concat(name, ": ").concat(value);
    }
  }, {
    key: "transform",
    value: function transform(t1, t2) {
      return [t1[0] * t2[0] + t1[2] * t2[1], t1[1] * t2[0] + t1[3] * t2[1], t1[0] * t2[2] + t1[2] * t2[3], t1[1] * t2[2] + t1[3] * t2[3], t1[0] * t2[4] + t1[2] * t2[5] + t1[4], t1[1] * t2[4] + t1[3] * t2[5] + t1[5]];
    }
  }, {
    key: "applyTransform",
    value: function applyTransform(p, m) {
      var xt = p[0] * m[0] + p[1] * m[2] + m[4];
      var yt = p[0] * m[1] + p[1] * m[3] + m[5];
      return [xt, yt];
    }
  }, {
    key: "applyInverseTransform",
    value: function applyInverseTransform(p, m) {
      var d = m[0] * m[3] - m[1] * m[2];
      var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[3] * m[4]) / d;
      var yt = (-p[0] * m[1] + p[1] * m[0] + m[1] * m[4] - m[0] * m[5]) / d;
      return [xt, yt];
    }
  }, {
    key: "getAxialAlignedBoundingBox",
    value: function getAxialAlignedBoundingBox(r, m) {
      var p1 = Util.applyTransform(r, m);
      var p2 = Util.applyTransform([r[0], r[3]], m);
      var p3 = Util.applyTransform([r[2], r[1]], m);
      var p4 = Util.applyTransform([r[2], r[3]], m);
      return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
    }
  }, {
    key: "inverse",
    value: function inverse(m) {
      var d = m[0] * m[3] - m[1] * m[2];
      return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[3] * m[4]) / d, (m[1] * m[4] - m[0] * m[5]) / d];
    }
  }, {
    key: "normalizeRect",
    value: function normalizeRect(r) {
      var r0 = r[0],
        r1 = r[1],
        r2 = r[2],
        r3 = r[3];
      var ret = [Math.min(r0, r2), Math.min(r1, r3), Math.max(r0, r2), Math.max(r1, r3)];
      return ret;
    }
  }, {
    key: "intersect",
    value: function intersect(r1, r2) {
      var ret = [Math.max(r1[0], r2[0]), Math.max(r1[1], r2[1]), Math.min(r1[2], r2[2]), Math.min(r1[3], r2[3])];
      return ret[2] > ret[0] && ret[3] > ret[1] ? ret : null;
    }
  }, {
    key: "union",
    value: function union(r1, r2) {
      return [Math.min(r1[0], r2[0]), Math.min(r1[1], r2[1]), Math.max(r1[2], r2[2]), Math.max(r1[3], r2[3])];
    }
  }, {
    key: "toString",
    value: function toString(arr) {
      return String.fromCharCode.apply(null, arr);
    }
  }, {
    key: "decimalDigits",
    value: function decimalDigits(v) {
      if (Math.floor(v) === v) {
        return 0;
      }
      var s = v.toString();
      var i = s.indexOf(".");
      if (i === -1) {
        return 0;
      }
      return s.length - i - 1;
    }
  }, {
    key: "roundToNext",
    value: function roundToNext(x) {
      var d = Math.pow(10, Util.decimalDigits(x) + 2);
      return Math.round(x * d) / d;
    }
  }, {
    key: "floor",
    value: function floor(x, n) {
      var d = Math.pow(10, n);
      return Math.floor(x * d) / d;
    }
  }, {
    key: "ceil",
    value: function ceil(x, n) {
      var d = Math.pow(10, n);
      return Math.ceil(x * d) / d;
    }
  }, {
    key: "clamp",
    value: function clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }
  }]);
  return Util;
}();
exports.Util = Util;
function getDisplacement(page) {
  var hDispl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var vDispl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (hDispl === 0 && vDispl === 0) {
    return null;
  }
  var _page$view = page.view,
    x1 = _page$view[0],
    y1 = _page$view[1],
    x2 = _page$view[2],
    y2 = _page$view[3];
  var width = x2 - x1;
  var height = y2 - y1;
  var h = hDispl * width / 100;
  var v = vDispl * height / 100;
  switch (page.rotate) {
    case 90:
      return [v, -h];
    case 180:
      return [-h, -v];
    case 270:
      return [-v, h];
  }
  return [h, v];
}
function getScaleFactor(page, oldWidth) {
  var hScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var vScale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  if (hScale === 1 && vScale === 1) {
    return null;
  }
  var _page$view2 = page.view,
    x1 = _page$view2[0],
    y1 = _page$view2[1],
    x2 = _page$view2[2],
    y2 = _page$view2[3];
  var width = x2 - x1;
  var height = y2 - y1;
  var newWidth = oldWidth * hScale;
  var scale = newWidth / width;
  return [scale, scale * vScale / hScale];
}
function normalizeAppearanceData(_ref3) {
  var font = _ref3.font,
    xref = _ref3.xref,
    acroForm = _ref3.acroForm;
  var fontRef = font.ref;
  var fontRes = font.font ? null : acroForm.common.get("DR").get(font.name);
  if (!fontRes) {
    var fontDict = font.createFontDict(fontRef, xref);
    acroForm.common.get("DR").set(font.name, fontDict);
  } else if (font.font) {
    var fontName = fontRes.get("Subtype").name;
    var _font$font$name = font.font.name,
      baseFontName = _font$font$name === void 0 ? "" : _font$font$name;
    baseFontName = baseFontName.replaceAll(" ", "");
    if (fontName === "Type1" && !baseFontName.includes(fontRes.get("BaseFont").name)) {
      var newFontName = acroForm.getNewFontName(font.name);
      var _fontDict = font.createFontDict(fontRef, xref);
      acroForm.common.get("DR").set(newFontName, _fontDict);
      font.name = newFontName;
    }
  }
}
function addLinkAttributes(link, _ref4) {
  var _ref4$url = _ref4.url,
    url = _ref4$url === void 0 ? null : _ref4$url,
    _ref4$dest = _ref4.dest,
    dest = _ref4$dest === void 0 ? null : _ref4$dest,
    _ref4$destRef = _ref4.destRef,
    destRef = _ref4$destRef === void 0 ? null : _ref4$destRef,
    _ref4$newWindow = _ref4.newWindow,
    newWindow = _ref4$newWindow === void 0 ? false : _ref4$newWindow,
    _ref4$colors = _ref4.colors,
    colors = _ref4$colors === void 0 ? null : _ref4$colors;
  if (url && typeof url === "string") {
    link.href = link.target = "";
    var absoluteUrl = createValidAbsoluteUrl(url);
    if (absoluteUrl) {
      link.href = absoluteUrl.href;
    } else {
      link.href = url;
    }
  } else if (dest && typeof dest === "string") {
    link.href = "#".concat(dest);
    link.target = "";
  } else if (destRef) {
    link.href = "#".concat(destRef.num, "R");
    link.target = "";
  } else {
    return;
  }
  if (newWindow) {
    link.target = "_blank";
  }
  if (colors) {
    for (var _i3 = 0, _Object$entries = Object.entries(colors); _i3 < _Object$entries.length; _i3++) {
      var _Object$entries$_i = _Object$entries[_i3],
        name = _Object$entries$_i[0],
        color = _Object$entries$_i[1];
      link.style[name] = color;
    }
  }
}
function noContextMenu(element, _ref5) {
  var _ref5$isTouch = _ref5.isTouch,
    isTouch = _ref5$isTouch === void 0 ? false : _ref5$isTouch;
  element.addEventListener("contextmenu", function (event) {
    event.preventDefault();
  });
  if (isTouch) {
    var timer = 0;
    var isDown = false;
    element.addEventListener("touchstart", function (event) {
      if (event.touches.length > 1) {
        return;
      }
      isDown = true;
      timer = setTimeout(function () {
        if (isDown) {
          element.dispatchEvent(new PointerEvent("contextmenu", {
            bubbles: true,
            cancelable: false,
            pointerId: event.touches[0].identifier,
            pointerType: "touch",
            clientX: event.touches[0].clientX,
            clientY: event.touches[0].clientY,
            isPrimary: true
          }));
        }
        isDown = false;
      }, 500);
    });
    element.addEventListener("touchend", function (event) {
      isDown = false;
      clearTimeout(timer);
    });
    element.addEventListener("touchmove", function (event) {
      isDown = false;
      clearTimeout(timer);
    });
  }
}
function dispatchGlobalEvent(name, detail) {
  var isStubs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (isStubs) {
    return;
  }
  if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
    var event = new CustomEvent(name, {
      bubbles: true,
      cancelable: true,
      detail: detail
    });
    window.dispatchEvent(event);
    return;
  }
  var event = document.createEvent("CustomEvent");
  event.initCustomEvent(name, true, true, detail);
  window.dispatchEvent(event);
}
var _asyncCounter = 0;
function finishAsyncOperation(id) {
  _asyncCounter--;
  dispatchGlobalEvent("pdfjs-async-operation", {
    id: id,
    asyncCounter: _asyncCounter,
    isEnded: true
  });
}
function createPromiseAllWhile(arr, predicate) {
  var isStubs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!predicate) {
    return Promise.all(arr);
  }
  var id = ++_asyncCounter;
  dispatchGlobalEvent("pdfjs-async-operation", {
    id: id,
    asyncCounter: _asyncCounter,
    isEnded: false
  }, isStubs);
  var onResolve = function onResolve() {
    finishAsyncOperation(id);
  };
  var onReject = onResolve;
  var all = Promise.all(arr);
  all.then(onResolve, onReject);
  return predicate ? all : all.then(function (results) {
    return results.filter(predicate);
  });
}
function createSuperscript(text) {
  var isNumber = /^\d+$/.test(text);
  if (!isNumber && text !== "st" && text !== "nd" && text !== "rd" && text !== "th") {
    return text;
  }
  var sup = document.createElement("sup");
  sup.textContent = text;
  var span = document.createElement("span");
  span.append(sup);
  return span;
}
function getOwnerPassword(data, start) {
  var MAX_OWNER_PASSWORD_LEN = 32;
  var end = Math.min(start + MAX_OWNER_PASSWORD_LEN, data.length);
  return stringToBytes(btoa(bytesToString(data.subarray(start, end))));
}
function getUserPassword(data, ownerPassword) {
  var userPassword = new Uint8Array(32);
  for (var i = 0; i < 32; i++) {
    var byte = data[i];
    if (i < ownerPassword.length) {
      byte ^= ownerPassword[i];
    }
    userPassword[i] = byte;
  }
  return userPassword;
}
function getModificationDate(data) {
  return new Date(Date.parse(bytesToString(data).slice(2, 16).replace(/(\d\d)(\d\d)$/, "$1:$2")));
}
function decodeSentences(data) {
  var kSentenceSeparator = 0;
  var kWordSeparator = 1;
  var kCharacterSeparator = 2;
  var kFinal = 3;
  var result = [];
  var currentSentence = [];
  var currentWord = [];
  var state = kSentenceSeparator;
  for (var i = 0, ii = data.length; i < ii; i++) {
    var code = data[i];
    switch (state) {
      case kSentenceSeparator:
        if (code === 0) {
          state = kWordSeparator;
        } else {
          result.push(currentSentence);
          currentSentence = [];
        }
        break;
      case kWordSeparator:
        if (code === 0) {
          state = kCharacterSeparator;
        } else {
          currentSentence.push(currentWord);
          currentWord = [];
        }
        break;
      case kCharacterSeparator:
        if (code === 0) {
          state = kFinal;
        } else {
          currentWord.push(code);
        }
        break;
      case kFinal:
        state = kSentenceSeparator;
        i--;
        break;
    }
  }
  return result;
}
function createPromiseCapability() {
  var capability = {};
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}
function createObjectURL(data, contentType) {
  var URL = window.URL || window.webkitURL;
  if (!URL || isNodeJS || typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL") && !URL.createObjectURL) {
    return null;
  }
  try {
    var blob = new Blob([data], {
      type: contentType
    });
    return URL.createObjectURL(blob);
  } catch (ex) {
    return null;
  }
}
function removeNullCharacters(str) {
  var i = str.indexOf("\x00");
  if (i === -1) {
    return str;
  }
  var strBuf = [];
  strBuf.push(str.substring(0, i));
  var nullCharCode = 0;
  while ((i = str.indexOf("\x00", i)) !== -1) {
    i++;
    if (str.charCodeAt(i) === nullCharCode) {
      continue;
    }
    var j = str.indexOf("\x00", i);
    if (j === -1) {
      strBuf.push(str.substring(i));
      break;
    }
    strBuf.push(str.substring(i, j));
  }
  return strBuf.join("");
}
function bytesToString(bytes) {
  if (bytes instanceof Uint8Array && !(typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) && typeof TextDecoder === "function") {
    try {
      return new TextDecoder().decode(bytes);
    } catch (e) {
      if (e.name === "RangeError") {} else {
        throw e;
      }
    }
  }
  var str = "";
  for (var i = 0, ii = bytes.length; i < ii; i++) {
    str += String.fromCharCode(bytes[i]);
  }
  return str;
}
function stringToBytes(str) {
  if (typeof str !== "string") {
    warn("Invalid argument for stringToBytes");
    return new Uint8Array(0);
  }
  var length = str.length;
  var bytes = new Uint8Array(length);
  for (var i = 0; i < length; i++) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}
function stringToPDFString(str) {
  var isHex = false;
  var i, n;
  for (i = 0, n = str.length; i < n; ++i) {
    var charCode = str.charCodeAt(i);
    if (charCode < 0x20 || charCode > 0x7E || charCode === 0x28 || charCode === 0x29 || charCode === 0x5C) {
      isHex = true;
      break;
    }
  }
  if (!isHex) {
    return "(" + str.replaceAll(/([\\()])/g, "\\$1") + ")";
  }
  var buf = [];
  for (i = 0; i < n; ++i) {
    var _charCode = str.charCodeAt(i);
    var hex = _charCode.toString(16);
    if (hex.length === 1) {
      hex = "0" + hex;
    }
    buf.push(hex);
  }
  return "<" + buf.join("") + ">";
}
function bytesToBase64(bytes) {
  var str = bytesToString(bytes);
  return btoa(str);
}
function base64ToBytes(base64, mayContainBase64Bytes) {
  var str = atob(base64);
  if (mayContainBase64Bytes) {
    var isBytes = true;
    for (var i = 0, ii = str.length; i < ii; i++) {
      if (str.charCodeAt(i) > 255) {
        isBytes = false;
        break;
      }
    }
    if (isBytes) {
      return stringToBytes(str);
    }
  }
  var arr = new Uint8Array(str.length);
  for (var _i4 = 0, _ii = str.length; _i4 < _ii; _i4++) {
    arr[_i4] = str.charCodeAt(_i4);
  }
  return arr;
}
function getFilenameFromUrl(url) {
  var urlObject = createValidAbsoluteUrl(url, "http://localhost/");
  if (!urlObject) {
    return url;
  }
  try {
    var _urlObject$pathname;
    var pathname = decodeURIComponent(urlObject.pathname);
    var pos = (_urlObject$pathname = pathname) === null || _urlObject$pathname === void 0 ? void 0 : _urlObject$pathname.lastIndexOf("/");
    return pos === -1 ? pathname : pathname.slice(pos + 1);
  } catch (ex) {
    return url;
  }
}
function createValidAbsoluteUrl(url) {
  var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!url || typeof url !== "string") {
    return null;
  }
  try {
    return new URL(url, baseUrl);
  } catch (ex) {
    return null;
  }
}
function isValidFetchUrl(url, baseUrl) {
  var absoluteUrl = createValidAbsoluteUrl(url, baseUrl);
  if (!absoluteUrl) {
    return false;
  }
  return absoluteUrl.protocol === "http:" || absoluteUrl.protocol === "https:" || absoluteUrl.protocol === "ftp:" || absoluteUrl.protocol === "file:" || absoluteUrl.protocol === "data:";
}
function isPdfFile(filename) {
  if (typeof filename !== "string") {
    return false;
  }
  var re = /\.pdf([?#].*)?$/i;
  return re.test(filename);
}
function isLittleEndian() {
  var buffer8 = new Uint8Array(2);
  buffer8[0] = 1;
  var buffer16 = new Uint16Array(buffer8.buffer);
  return buffer16[0] === 1;
}
function combineUrl(baseUrl, url) {
  if (!url) {
    return baseUrl;
  }
  if (isNodeJS) {
    var _require = require("path");
    return _require.join(baseUrl, url);
  }
  return new URL(url, baseUrl).href;
}
function getAnchorElement(url) {
  var a = document.createElement("a");
  a.href = url;
  return a;
}
function normalizeURL(url) {
  if (isNodeJS) {
    return url;
  }
  var anchor = getAnchorElement(url);
  return anchor.href;
}
function parseQueryString(query) {
  var params = Object.create(null);
  var i, ii, param;
  if (!query) {
    return params;
  }
  var queryString = query.substring(1);
  var paramsStrings = queryString.split("&");
  for (i = 0, ii = paramsStrings.length; i < ii; ++i) {
    param = paramsStrings[i].split("=");
    params[decodeURIComponent(param[0])] = decodeURIComponent(param[1]);
  }
  return params;
}
function verifyFirstPageCoversTheRange(instance, range) {
  if (instance.firstPage) {
    var start = range.begin;
    var end = range.begin + range.length;
    var firstPageLength = instance.firstPage.byteLength;
    if (start < firstPageLength && end <= firstPageLength) {
      return true;
    }
  }
  return false;
}
function validateRange(begin, end) {
  if (typeof begin !== "number" || typeof end !== "number") {
    throw new Error("Invalid numeric argument");
  }
  if (begin < 0 || end < 0 || end < begin) {
    throw new Error("Invalid range: [" + begin + ", " + end + ")");
  }
}
function validateUrl(url) {
  if (!url) {
    return false;
  }
  if (url.startsWith("blob:") || url.startsWith("data:")) {
    return true;
  }
  var protocol = /^[a-z][a-z0-9.+-]*:/i.exec(url);
  return !protocol || protocol[0] === "http:" || protocol[0] === "https:" || protocol[0] === "ftp:";
}
function isObject(v) {
  return _typeof(v) === "object" && v !== null;
}
function cloneObj(obj) {
  var result = Object.create(null);
  for (var i in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, i)) {
      result[i] = obj[i];
    }
  }
  return result;
}
var AbortException = function (_Error) {
  _inherits(AbortException, _Error);
  var _super = _createSuper(AbortException);
  function AbortException(message) {
    var _this;
    _classCallCheck(this, AbortException);
    _this = _super.call(this, "An API call was pending and aborted: ".concat(message));
    _this.name = "AbortException";
    return _this;
  }
  return _createClass(AbortException);
}(_wrapError(Error));
exports.AbortException = AbortException;
var InvalidPDFException = function (_Error2) {
  _inherits(InvalidPDFException, _Error2);
  var _super2 = _createSuper(InvalidPDFException);
  function InvalidPDFException(message) {
    var _this2;
    _classCallCheck(this, InvalidPDFException);
    _this2 = _super2.call(this, message);
    _this2.name = "InvalidPDFException";
    return _this2;
  }
  return _createClass(InvalidPDFException);
}(_wrapError(Error));
exports.InvalidPDFException = InvalidPDFException;
var MissingPDFException = function (_Error3) {
  _inherits(MissingPDFException, _Error3);
  var _super3 = _createSuper(MissingPDFException);
  function MissingPDFException(message) {
    var _this3;
    _classCallCheck(this, MissingPDFException);
    _this3 = _super3.call(this, message);
    _this3.name = "MissingPDFException";
    return _this3;
  }
  return _createClass(MissingPDFException);
}(_wrapError(Error));
exports.MissingPDFException = MissingPDFException;
var RenderingCancelledException = function (_Error4) {
  _inherits(RenderingCancelledException, _Error4);
  var _super4 = _createSuper(RenderingCancelledException);
  function RenderingCancelledException(message, intent) {
    var _this4;
    _classCallCheck(this, RenderingCancelledException);
    _this4 = _super4.call(this, message);
    _this4.name = "RenderingCancelledException";
    _this4.intent = intent;
    return _this4;
  }
  return _createClass(RenderingCancelledException);
}(_wrapError(Error));
exports.RenderingCancelledException = RenderingCancelledException;
var UnexpectedResponseException = function (_Error5) {
  _inherits(UnexpectedResponseException, _Error5);
  var _super5 = _createSuper(UnexpectedResponseException);
  function UnexpectedResponseException(message, status) {
    var _this5;
    _classCallCheck(this, UnexpectedResponseException);
    _this5 = _super5.call(this, message);
    _this5.name = "UnexpectedResponseException";
    _this5.status = status;
    return _this5;
  }
  return _createClass(UnexpectedResponseException);
}(_wrapError(Error));
exports.UnexpectedResponseException = UnexpectedResponseException;
var _Symbol$toStringTag;
function _wrapError(w) {
  var c = function c(a) {
    for (var _len = arguments.length, b = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      b[_key - 1] = arguments[_key];
    }
    a instanceof w ? w.apply(this, [a].concat(b)) : w.call(this, a);
  };
  _Symbol$toStringTag = Symbol.toStringTag;
  c.prototype = Object.create(w.prototype, {
    constructor: {
      value: c
    },
    [Symbol.toStringTag]: {
      value: "Error"
    }
  });
  return c;
}
var PasswordException = function (_Error6) {
  _inherits(PasswordException, _Error6);
  var _super6 = _createSuper(PasswordException);
  function PasswordException(message, code) {
    var _this6;
    _classCallCheck(this, PasswordException);
    _this6 = _super6.call(this, message);
    _this6.name = "PasswordException";
    _this6.code = code;
    return _this6;
  }
  return _createClass(PasswordException);
}(_wrapError(Error));
var UnknownErrorException = function (_Error7) {
  _inherits(UnknownErrorException, _Error7);
  var _super7 = _createSuper(UnknownErrorException);
  function UnknownErrorException(message, details) {
    var _this7;
    _classCallCheck(this, UnknownErrorException);
    _this7 = _super7.call(this, message);
    _this7.name = "UnknownErrorException";
    _this7.details = details;
    return _this7;
  }
  return _createClass(UnknownErrorException);
}(_wrapError(Error));
var OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLIne: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineShowSpacedText: 47,
  setStrokeColorSpace: 48,
  setFillColorSpace: 49,
  setStrokeColor: 50,
  setStrokeColorN: 51,
  setFillColor: 52,
  setFillColorN: 53,
  setStrokeGray: 54,
  setFillGray: 55,
  setStrokeRGBColor: 56,
  setFillRGBColor: 57,
  setStrokeCMYKColor: 58,
  setFillCMYKColor: 59,
  shadingFill: 60,
  beginInlineImage: 61,
  beginImageData: 62,
  endInlineImage: 63,
  paintXObject: 64,
  markPoint: 65,
  markPointProps: 66,
  beginMarkedContent: 67,
  beginMarkedContentProps: 68,
  endMarkedContent: 69,
  beginCompat: 70,
  endCompat: 71,
  paintFormXObjectBegin: 72,
  paintFormXObjectEnd: 73,
  beginGroup: 74,
  endGroup: 75,
  beginTilingPattern: 76,
  endTilingPattern: 77,
  paintShading: 78,
  paintImageMaskXObject: 79,
  paintImageMaskXObjectGroup: 80,
  paintImageXObject: 81,
  paintInlineImageXObject: 82,
  paintInlineImageXObjectGroup: 83,
  paintImageXObjectRepeat: 84,
  paintImageMaskXObjectRepeat: 85,
  paintSolidColorImageMask: 86,
  constructPath: 87
};
exports.OPS = OPS;
function approximateFraction(x) {
  if (Math.floor(x) === x) {
    return [x, 1];
  }
  var x_ = x > 1 ? 1 / x : x;
  var d = new Uint32Array([0, 1, 0, 0, 1, 1]);
  var n1 = 1,
    n2 = 0;
  var d1 = 0,
    d2 = 1;
  while (true) {
    var q = Math.floor(x_);
    var r = x_ - q;
    var tempN = n1;
    var tempD = d1;
    n1 = q * n1 + n2;
    d1 = q * d1 + d2;
    n2 = tempN;
    d2 = tempD;
    if (r < 0.000001) {
      break;
    }
    x_ = 1 / r;
  }
  if (x > 1) {
    return [d1, n1];
  }
  return [n1, d1];
}
function parseDestArray(destArray) {
  var rawDest = destArray.getResolved();
  if (!(rawDest instanceof Array)) {
    warn("parseDestArray: invalid destination array.");
    return null;
  }
  if (rawDest.length === 0) {
    warn("parseDestArray: empty destination array.");
    return null;
  }
  var first = destArray.get(0);
  if (first instanceof Promise) {
    warn("parseDestArray: destination array not resolved.");
    return null;
  }
  var dest, pageNumber, pageRef;
  if (isObject(first)) {
    pageRef = first;
    rawDest.shift();
    dest = rawDest;
  } else if (Number.isInteger(first)) {
    pageNumber = first;
    rawDest.shift();
    dest = rawDest;
  } else if (typeof first === "string") {
    pageNumber = first;
    dest = rawDest;
  } else {
    warn("parseDestArray: invalid page reference in destination array.");
    return null;
  }
  return {
    dest: dest,
    pageNumber: pageNumber,
    pageRef: pageRef
  };
}
function apiPageLayoutToViewerModes(layout) {
  var viewerModes = {
    spreadMode: 0,
    scrollMode: 3
  };
  switch (layout) {
    case "SinglePage":
      break;
    case "OneColumn":
      viewerModes.scrollMode = 0;
      break;
    case "TwoPageLeft":
      viewerModes.spreadMode = 1;
      break;
    case "TwoColumnLeft":
      viewerModes.scrollMode = 1;
      viewerModes.spreadMode = 1;
      break;
    case "TwoPageRight":
      viewerModes.spreadMode = 2;
      break;
    case "TwoColumnRight":
      viewerModes.scrollMode = 1;
      viewerModes.spreadMode = 2;
      break;
    default:
      return null;
  }
  return viewerModes;
}
function apiPageModeToViewerModes(mode) {
  var viewerModes = {
    thumbnail: false,
    layers: false
  };
  switch (mode) {
    case "UseNone":
      break;
    case "UseThumbs":
      viewerModes.thumbnail = true;
      break;
    case "UseOutlines":
      break;
    case "FullScreen":
      break;
    case "UseOC":
      viewerModes.layers = true;
      break;
    case "UseAttachments":
      break;
    default:
      return null;
  }
  return viewerModes;
}
function transform(m1, m2) {
  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
}
function transformBox(box, transform) {
  var x = box[0],
    y = box[1],
    w = box[2],
    h = box[3];
  var p1 = [x, y];
  var p2 = [x + w, y];
  var p3 = [x, y + h];
  var p4 = [x + w, y + h];
  var pt1 = Util.applyTransform(p1, transform);
  var pt2 = Util.applyTransform(p2, transform);
  var pt3 = Util.applyTransform(p3, transform);
  var pt4 = Util.applyTransform(p4, transform);
  return [Math.min(pt1[0], pt2[0], pt3[0], pt4[0]), Math.min(pt1[1], pt2[1], pt3[1], pt4[1]), Math.max(pt1[0], pt2[0], pt3[0], pt4[0]), Math.max(pt1[1], pt2[1], pt3[1], pt4[1])];
}
function calculateTransform(width, height, box) {
  var x = box[0],
    y = box[1],
    w = box[2],
    h = box[3];
  var scaleX = width / w;
  var scaleY = height / h;
  var scale = Math.min(scaleX, scaleY);
  var tx = -x * scale + (width - w * scale) / 2;
  var ty = -y * scale + (height - h * scale) / 2;
  return [scale, 0, 0, -scale, tx, ty + height];
}
function integerToBytes(n, size) {
  var bytes = new Uint8Array(size);
  for (var i = size - 1; i >= 0; i--) {
    bytes[i] = n & 255;
    n >>= 8;
  }
  return bytes;
}
function numberToBytes(n, size) {
  if (Number.isInteger(n)) {
    return integerToBytes(n, size);
  }
  var float = new Float64Array(1);
  float[0] = n;
  var bytes = new Uint8Array(float.buffer, 0, size);
  var result = new Uint8Array(size);
  result.set(bytes);
  return result;
}
function numberToHex(n) {
  var hex = Math.floor(n).toString(16);
  if (hex.length % 2 === 1) {
    hex = "0" + hex;
  }
  return hex;
}
function getZlib(obj) {
  return obj.stream.getZlib();
}
function createPageGetViewport(page) {
  return function (scale) {
    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref6$rotate = _ref6.rotate,
      rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,
      _ref6$offsetX = _ref6.offsetX,
      offsetX = _ref6$offsetX === void 0 ? 0 : _ref6$offsetX,
      _ref6$offsetY = _ref6.offsetY,
      offsetY = _ref6$offsetY === void 0 ? 0 : _ref6$offsetY,
      _ref6$dontFlip = _ref6.dontFlip,
      dontFlip = _ref6$dontFlip === void 0 ? false : _ref6$dontFlip;
    var _page$view3 = page.view,
      x1 = _page$view3[0],
      y1 = _page$view3[1],
      x2 = _page$view3[2],
      y2 = _page$view3[3];
    var pageRotation = (page.rotate + rotate) % 360;
    var width = x2 - x1;
    var height = y2 - y1;
    var viewportWidth, viewportHeight;
    if (pageRotation === 90 || pageRotation === 270) {
      viewportWidth = height;
      viewportHeight = width;
    } else {
      viewportWidth = width;
      viewportHeight = height;
    }
    var transform;
    switch (pageRotation) {
      case 0:
        transform = [1, 0, 0, -1, -x1, y2];
        break;
      case 90:
        transform = [0, 1, -1, 0, y2, -x1];
        break;
      case 180:
        transform = [-1, 0, 0, 1, x2, -y1];
        break;
      case 270:
        transform = [0, -1, 1, 0, -y1, x2];
        break;
      default:
        throw new Error("Invalid page rotation");
    }
    transform = [scale, 0, 0, scale, offsetX, offsetY];
    return {
      width: viewportWidth,
      height: viewportHeight,
      fontScale: scale,
      transforms: [transform, page.transform],
      rotate: rotate,
      offsetX: offsetX,
      offsetY: offsetY,
      dontFlip: dontFlip
    };
  };
}
function postMessageTransfers(worker, aMessage, transfers) {
  if (isNodeJS) {
    worker.postMessage(aMessage);
    return;
  }
  worker.postMessage(aMessage, transfers);
}
var PDFWorker = function () {
  function PDFWorker() {
    _classCallCheck(this, PDFWorker);
  }
  _createClass(PDFWorker, [{
    key: "messageHandler",
    get: function get() {
      return this._messageHandler;
    }
  }]);
  return PDFWorker;
}();
exports.PDFWorker = PDFWorker;
var PDFDataRangeTransport = function () {
  function PDFDataRangeTransport(length, initialData, progressiveDone) {
    _classCallCheck(this, PDFDataRangeTransport);
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.isStreamingSupported = true;
    this.isRangeSupported = true;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._progressiveDoneListeners = [];
    this.onDataRange = this._onDataRange.bind(this);
    this.onDataProgress = this._onDataProgress.bind(this);
    this.onDataProgressiveRead = this._onDataProgressiveRead.bind(this);
    this.onDataProgressiveDone = this._onDataProgressiveDone.bind(this);
    this.requestDataRange = this._requestDataRange.bind(this);
  }
  _createClass(PDFDataRangeTransport, [{
    key: "addRangeListener",
    value: function addRangeListener(listener) {
      this._rangeListeners.push(listener);
    }
  }, {
    key: "addProgressListener",
    value: function addProgressListener(listener) {
      this._progressListeners.push(listener);
    }
  }, {
    key: "addProgressiveReadListener",
    value: function addProgressiveReadListener(listener) {
      this._progressiveReadListeners.push(listener);
    }
  }, {
    key: "addProgressiveDoneListener",
    value: function addProgressiveDoneListener(listener) {
      this._progressiveDoneListeners.push(listener);
    }
  }, {
    key: "removeRangeListener",
    value: function removeRangeListener(listener) {
      var i = this._rangeListeners.indexOf(listener);
      if (i >= 0) {
        this._rangeListeners.splice(i, 1);
      }
    }
  }, {
    key: "_onDataRange",
    value: function _onDataRange(begin, chunk) {
      var _iterator = _createForOfIteratorHelper(this._rangeListeners),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var listener = _step.value;
          listener(begin, chunk);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "_onDataProgress",
    value: function _onDataProgress(loaded, total) {
      var _iterator2 = _createForOfIteratorHelper(this._progressListeners),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var listener = _step2.value;
          listener(loaded, total);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "_onDataProgressiveRead",
    value: function _onDataProgressiveRead(chunk) {
      var _iterator3 = _createForOfIteratorHelper(this._progressiveReadListeners),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var listener = _step3.value;
          listener(chunk);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "_onDataProgressiveDone",
    value: function _onDataProgressiveDone() {
      var _iterator4 = _createForOfIteratorHelper(this._progressiveDoneListeners),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var listener = _step4.value;
          listener();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "_requestDataRange",
    value: function _requestDataRange(begin, end) {
      throw new Error("Abstract method PDFDataRangeTransport._requestDataRange");
    }
  }, {
    key: "abort",
    value: function abort() {}
  }]);
  return PDFDataRangeTransport;
}();
exports.PDFDataRangeTransport = PDFDataRangeTransport;
var ProgressBar = function () {
  function ProgressBar(bar, _ref7) {
    var _ref7$height = _ref7.height,
      height = _ref7$height === void 0 ? 100 : _ref7$height,
      _ref7$width = _ref7.width,
      width = _ref7$width === void 0 ? 100 : _ref7$width,
      _ref7$units = _ref7.units,
      units = _ref7$units === void 0 ? "%" : _ref7$units,
      _ref7$bg = _ref7.bg,
      bg = _ref7$bg === void 0 ? "transparent" : _ref7$bg,
      _ref7$colors = _ref7.colors,
      colors = _ref7$colors === void 0 ? null : _ref7$colors,
      _ref7$min = _ref7.min,
      min = _ref7$min === void 0 ? 0 : _ref7$min,
      _ref7$max = _ref7.max,
      max = _ref7$max === void 0 ? 100 : _ref7$max;
    _classCallCheck(this, ProgressBar);
    this.bar = bar;
    this.height = height;
    this.width = width;
    this.units = units;
    this.bg = bg;
    this.colors = colors;
    this.min = min;
    this.max = max;
    this.value = min;
    this.percent = 0;
    this._updateBar();
  }
  _createClass(ProgressBar, [{
    key: "setValue",
    value: function setValue(val) {
      this.value = val;
      this.percent = (this.value - this.min) * 100 / (this.max - this.min);
      this._updateBar();
    }
  }, {
    key: "setPercent",
    value: function setPercent(percent) {
      this.percent = percent;
      this.value = this.min + (this.max - this.min) * percent / 100;
      this._updateBar();
    }
  }, {
    key: "_updateBar",
    value: function _updateBar() {
      if (this.percent < 0) {
        this.percent = 0;
      }
      if (this.percent > 100) {
        this.percent = 100;
      }
      this.bar.style.height = this.height + this.units;
      this.bar.style.width = this.width + this.units;
      this.bar.style.backgroundColor = this.bg;
      var div = this.bar.firstElementChild;
      div.style.height = this.bar.style.height;
      div.style.width = this.percent + "%";
      if (this.colors) {
        div.style.backgroundColor = this.colors.get(this.value);
      }
    }
  }]);
  return ProgressBar;
}();
exports.ProgressBar = ProgressBar;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var SVGGraphics = function () {
  function SVGGraphics(commonObjs, page, xref) {
    _classCallCheck(this, SVGGraphics);
    this.svgFactory = new _svg.SVGFactory();
    this.commonObjs = commonObjs;
    this.page = page;
    this.xref = xref;
    this.pendingForms = new Set();
  }
  _createClass(SVGGraphics, [{
    key: "getSVG",
    value: function getSVG(operatorList, viewport) {
      var _this8 = this;
      this.current = this.svgFactory.create(viewport.width, viewport.height);
      var transform = [1, 0, 0, -1, 0, viewport.height];
      this.transformMatrix = (0, _util.transform)(viewport.transform, transform);
      return this._beginDrawing(viewport, operatorList).then(function () {
        return _this8.current;
      });
    }
  }, {
    key: "save",
    value: function save() {
      this.current.save();
    }
  }, {
    key: "restore",
    value: function restore() {
      this.current.restore();
    }
  }, {
    key: "_beginDrawing",
    value: function _beginDrawing(viewport, operatorList) {
      this.current.save();
      this.current.transform.apply(this.current, this.transformMatrix);
      return this.executeOperatorList(operatorList);
    }
  }, {
    key: "executeOperatorList",
    value: function executeOperatorList(operatorList) {
      var _this9 = this;
      var argsArray = operatorList.argsArray;
      var fnArray = operatorList.fnArray;
      var promise = Promise.resolve();
      var _loop = function _loop(i, ii) {
        if (fnArray[i] === _util.OPS.paintFormXObjectBegin) {
          var args = argsArray[i];
          var formObj = _this9.commonObjs.get(args[0].name);
          _this9.pendingForms.add(formObj);
          return "continue";
        }
        promise = promise.then(function () {
          var args = argsArray[i] || [];
          if (fnArray[i] === _util.OPS.paintFormXObjectEnd) {
            if (_this9.pendingForms.size === 0) {
              return undefined;
            }
            var _formObj;
            var _iterator5 = _createForOfIteratorHelper(_this9.pendingForms),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var item = _step5.value;
                if (!item.operatorList) {
                  continue;
                }
                _formObj = item;
                break;
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
            _this9.pendingForms.delete(_formObj);
            return _this9.executeOperatorList(_formObj.operatorList);
          }
          if (fnArray[i] !== undefined) {
            return _this9.op(fnArray[i], args);
          }
          return undefined;
        });
      };
      for (var i = 0, ii = fnArray.length; i < ii; i++) {
        var _ret = _loop(i);
        if (_ret === "continue") continue;
      }
      return promise.then(function () {
        _this9.current.restore();
      }, function (reason) {
        _this9.current.restore();
        throw reason;
      });
    }
  }, {
    key: "op",
    value: function op(fn, args) {
      var _this10 = this;
      switch (fn) {
        case _util.OPS.save:
          this.save();
          break;
        case _util.OPS.restore:
          this.restore();
          break;
        case _util.OPS.beginText:
          this.current.beginText();
          break;
        case _util.OPS.endText:
          this.current.endText();
          break;
        case _util.OPS.setFont:
          this.current.setFont(args);
          break;
        case _util.OPS.showText:
          this.current.showText(args[0]);
          break;
        case _util.OPS.showSpacedText:
          this.current.showSpacedText(args[0]);
          break;
        case _util.OPS.setTextMatrix:
          this.current.setTextMatrix(args);
          break;
        case _util.OPS.setLineWidth:
          this.current.setLineWidth(args[0]);
          break;
        case _util.OPS.setStrokeColor:
          this.current.setStrokeColor(args);
          break;
        case _util.OPS.setFillColor:
          this.current.setFillColor(args);
          break;
        case _util.OPS.setDash:
          this.current.setDash(args);
          break;
        case _util.OPS.moveTo:
          this.current.moveTo(args);
          break;
        case _util.OPS.lineTo:
          this.current.lineTo(args);
          break;
        case _util.OPS.curveTo:
          this.current.curveTo(args);
          break;
        case _util.OPS.curveTo2:
          this.current.curveTo2(args);
          break;
        case _util.OPS.curveTo3:
          this.current.curveTo3(args);
          break;
        case _util.OPS.closePath:
          this.current.closePath();
          break;
        case _util.OPS.rectangle:
          this.current.rectangle(args);
          break;
        case _util.OPS.stroke:
          this.current.stroke();
          break;
        case _util.OPS.fill:
          this.current.fill();
          break;
        case _util.OPS.eoFill:
          this.current.eoFill();
          break;
        case _util.OPS.fillStroke:
          this.current.fillStroke();
          break;
        case _util.OPS.eoFillStroke:
          this.current.eoFillStroke();
          break;
        case _util.OPS.clip:
          this.current.clip();
          break;
        case _util.OPS.eoClip:
          this.current.eoClip();
          break;
        case _util.OPS.paintShading:
          var
          shading = this.commonObjs.get(args[0].name);
          return this.current.paintShading(shading);
        case _util.OPS.paintImageXObject:
          var name = args[0].name;
          var img = this.commonObjs.get(name);
          if (!img) {
            warn("Dependent image isn't ready yet");
            var dependency = new _util.PromiseCapability();
            this.commonObjs.get(name, function (resolvedImg) {
              if (resolvedImg) {
                _this10.op(_util.OPS.paintImageXObject, args);
              }
              dependency.resolve();
            });
            return dependency.promise;
          }
          this.current.paintImageXObject(img);
          break;
        case _util.OPS.dependency:
          var dependencies = args[0];
          var promises = [];
          var _iterator6 = _createForOfIteratorHelper(dependencies),
            _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var dependencyName = _step6.value;
              var dependency = this.commonObjs.get(dependencyName);
              if (!dependency) {
                var _dependency = new _util.PromiseCapability();
                promises.push(_dependency.promise);
                this.commonObjs.get(dependencyName, function (resolved) {
                  _dependency.resolve();
                });
              }
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
          return Promise.all(promises);
        default:
          warn("Unimplemented command ".concat(fn));
          break;
      }
      return undefined;
    }
  }]);
  return SVGGraphics;
}();
exports.SVGGraphics = SVGGraphics;
function objectSize(obj) {
  var size = 0;
  for (var key in obj) {
    size++;
  }
  return size;
}
var XfaLayer = function () {
  function XfaLayer() {
    _classCallCheck(this, XfaLayer);
  }
  _createClass(XfaLayer, null, [{
    key: "render",
    value: function render(_ref8) {
      var _this11 = this;
      var xfaHtml = _ref8.xfaHtml,
        viewport = _ref8.viewport,
        linkService = _ref8.linkService,
        annotationStorage = _ref8.annotationStorage,
        _ref8$svgFactory = _ref8.svgFactory,
        svgFactory = _ref8$svgFactory === void 0 ? new _svg.SVGFactory() : _ref8$svgFactory,
        _ref8$structTree = _ref8.structTree,
        structTree = _ref8$structTree === void 0 ? null : _ref8$structTree,
        _ref8$intent = _ref8.intent,
        intent = _ref8$intent === void 0 ? "display" : _ref8$intent,
        _ref8$imageResources = _ref8.imageResources,
        imageResources = _ref8$imageResources === void 0 ? {} : _ref8$imageResources;
      if (!xfaHtml) {
        return Promise.resolve({
          svg: null,
          parameters: null
        });
      }
      return this._render(svgFactory, xfaHtml, viewport, imageResources).then(function (svg) {
        if (!svg) {
          return {
            svg: null,
            parameters: null
          };
        }
        var parameters = {
          hasBg: false
        };
        _this11._setAnnotations({
          svg: svg,
          xfaHtml: xfaHtml,
          linkService: linkService,
          annotationStorage: annotationStorage,
          imageResources: imageResources,
          parameters: parameters,
          structTree: structTree,
          intent: intent
        });
        return {
          svg: svg,
          parameters: parameters
        };
      });
    }
  }, {
    key: "_render",
    value: function _render(svgFactory, xfaHtml, viewport, imageResources) {
      var svg = svgFactory.create(viewport.width, viewport.height);
      var id = xfaHtml.attributes.id || "xfa-".concat(Math.floor(Math.random() * 10000));
      svg.setAttribute("id", id);
      var defs = svgFactory.create("defs");
      svg.append(defs);
      var current = svg;
      var stack = [xfaHtml];
      var parent = null;
      var path = null;
      var partial = null;
      var transformations = {};
      var _loop2 = function _loop2() {
        var xfa = stack.shift();
        if (xfa.name === "#text") {
          current.textContent = xfa.value;
          return "continue";
        }
        var transform = new _transform_stream.TransformStream();
        transform.transform = (0, _util.transform)(parent ? parent.transform || _util.IDENTITY_MATRIX : _util.IDENTITY_MATRIX, xfa.transform);
        var attributes = {
          id: xfa.attributes.id,
          class: xfa.attributes["class"] ? xfa.attributes["class"].join(" ") : null,
          style: xfa.attributes.style
        };
        var node = svgFactory.create(xfa.name, attributes);
        if (xfa.attributes.xmlns) {
          node.setAttribute("xmlns", xfa.attributes.xmlns);
        }
        switch (xfa.name) {
          case "svg":
            var width = xfa.attributes.style.width,
              height = xfa.attributes.style.height;
            if (width !== "100%" || height !== "100%") {
              current.style.width = width;
              current.style.height = height;
            }
            if (xfa.attributes.viewBox) {
              current.setAttribute("viewBox", xfa.attributes.viewBox);
            }
            if (!xfa.attributes.preserveAspectRatio) {
              current.setAttribute("preserveAspectRatio", "none");
            } else {
              current.setAttribute("preserveAspectRatio", xfa.attributes.preserveAspectRatio);
            }
            break;
          case "foreignObject":
            node.setAttribute("width", xfa.attributes.width);
            node.setAttribute("height", xfa.attributes.height);
            node.setAttribute("x", xfa.attributes.x);
            node.setAttribute("y", xfa.attributes.y);
            node.setAttribute("transform", xfa.attributes.transform);
            var div = document.createElement("div");
            div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
            div.setAttribute("class", "xfaRichText");
            div.innerHTML = xfa.attributes.content.replaceAll(/<br\/>/g, "<br>").replaceAll(/\r/g, "");
            node.append(div);
            break;
          case "image":
            node.setAttribute("width", xfa.attributes.width);
            node.setAttribute("height", xfa.attributes.height);
            node.setAttribute("transform", xfa.attributes.transform);
            node.setAttribute("x", xfa.attributes.x);
            node.setAttribute("y", xfa.attributes.y);
            var image = imageResources[xfa.attributes.src];
            if (image) {
              node.setAttribute("href", image.src);
            }
            break;
          case "rect":
            node.setAttribute("width", xfa.attributes.width);
            node.setAttribute("height", xfa.attributes.height);
            node.setAttribute("x", xfa.attributes.x);
            node.setAttribute("y", xfa.attributes.y);
            node.setAttribute("rx", xfa.attributes.rx);
            node.setAttribute("ry", xfa.attributes.ry);
            break;
          case "ellipse":
            node.setAttribute("rx", xfa.attributes.rx);
            node.setAttribute("ry", xfa.attributes.ry);
            node.setAttribute("cx", xfa.attributes.cx);
            node.setAttribute("cy", xfa.attributes.cy);
            break;
          case "polyline":
          case "polygon":
            node.setAttribute("points", xfa.attributes.points);
            break;
          case "path":
            if (partial) {
              var d = [];
              for (var _i5 = 0, _ii2 = partial.length; _i5 < _ii2; _i5++) {
                d.push(path.get(partial[_i5]));
              }
              node.setAttribute("d", d.join(" "));
            } else {
              node.setAttribute("d", xfa.attributes.d);
            }
            break;
          case "defs":
            var id = xfa.attributes.id;
            if (id && id.startsWith("path-")) {
              if (!path) {
                path = new Map();
              }
              for (var _i6 = 0, _ii3 = xfa.children.length; _i6 < _ii3; _i6++) {
                var p = xfa.children[_i6];
                path.set(p.attributes.id, p.attributes.d);
              }
            } else if (id && id.startsWith("partial-")) {
              if (!partial) {
                partial = [];
              }
              partial.push(xfa.attributes["data-path"]);
            }
            break;
          case "g":
            var _id = xfa.attributes.id;
            if (_id && _id.startsWith("transform-")) {
              transformations[_id] = xfa.attributes.transform;
            } else if (xfa.attributes["data-transform"]) {
              var data = xfa.attributes["data-transform"];
              var t = transformations[data];
              if (t) {
                node.setAttribute("transform", t);
              }
            }
        }
        current.append(node);
        if (xfa.children) {
          xfa.children.forEach(function (child) {
            child.parent = xfa;
          });
          stack.push.apply(stack, xfa.children);
          parent = xfa;
          parent.node = node;
          current = node;
        } else {
          var _parent = xfa.parent;
          while (_parent && !stack.find(function (s) {
            return s.parent === _parent;
          })) {
            current = parent.node.parentNode;
            _parent = _parent.parent;
            parent = _parent;
          }
        }
      };
      while (stack.length > 0) {
        var _ret2 = _loop2();
        if (_ret2 === "continue") continue;
      }
      return Promise.resolve(svg);
    }
  }, {
    key: "_setAnnotations",
    value: function _setAnnotations(_ref9) {
      var svg = _ref9.svg,
        xfaHtml = _ref9.xfaHtml,
        linkService = _ref9.linkService,
        annotationStorage = _ref9.annotationStorage,
        imageResources = _ref9.imageResources,
        parameters = _ref9.parameters,
        structTree = _ref9.structTree,
        intent = _ref9.intent;
      var stack = [xfaHtml];
      var elements = new Map();
      var _loop3 = function _loop3() {
        var xfa = stack.shift();
        var node = svg.querySelector("[id=\"".concat(xfa.attributes.id, "\"]"));
        if (!node) {
          if (xfa.children) {
            stack.push.apply(stack, xfa.children);
          }
          return "continue";
        }
        var annotation = _xfa_layer.Annotation.fromXfa(xfa);
        if (annotation) {
          if (annotation.type === "choice") {
            var i = 0;
            var _iterator7 = _createForOfIteratorHelper(node.children),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var child = _step7.value;
                elements.set("".concat(annotation.id, "-").concat(i++), child);
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          } else {
            elements.set(annotation.id, node);
          }
          annotation.render(intent, {
            linkService: linkService,
            annotationStorage: annotationStorage,
            imageResources: imageResources,
            svg: svg,
            parameters: parameters,
            structTree: structTree,
            elements: elements
          });
        }
        if (xfa.children) {
          stack.push.apply(stack, xfa.children);
        }
      };
      while (stack.length > 0) {
        var _ret3 = _loop3();
        if (_ret3 === "continue") continue;
      }
    }
  }]);
  return XfaLayer;
}();
exports.XfaLayer = XfaLayer;
function objectFromMap(map) {
  var obj = Object.create(null);
  var _iterator8 = _createForOfIteratorHelper(map.entries()),
    _step8;
  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var _step8$value = _step8.value,
        key = _step8$value[0],
        value = _step8$value[1];
      obj[key] = value;
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
  return obj;
}

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WorkerMessageHandler = void 0;
var _util = __webpack_require__(1);
var _pdf = __webpack_require__(3);
var _is_node = __webpack_require__(10);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var WorkerMessageHandler = function () {
  function WorkerMessageHandler() {
    _classCallCheck(this, WorkerMessageHandler);
  }
  _createClass(WorkerMessageHandler, null, [{
    key: "setup",
    value: function setup(handler, port) {
      var _this = this;
      var testMessageProcessed = false;
      handler.on("test", function (data) {
        if (testMessageProcessed) {
          return;
        }
        testMessageProcessed = true;
        if (!_is_node.isNodeJS) {
          _this.sendWithPromise("test", null, [port]);
        } else {
          _this.sendWithPromise("test", null);
        }
      });
      handler.on("configure", function (data) {
        (0, _util.setVerbosityLevel)(data.verbosity);
        var _loop = function _loop() {
          var name = _Object$keys[_i];
          if (data.apiOption[name] !== undefined) {
            _util.apiParameters[name] = data.apiOption[name];
          }
        };
        for (var _i = 0, _Object$keys = Object.keys(data.apiOption); _i < _Object$keys.length; _i++) {
          _loop();
        }
      });
      handler.on("GetDocRequest", function (data, sink) {
        sink.onpull = function () {};
        sink.oncancel = function (reason) {};
        var pdfManager = new _pdf.PDFManager(handler, data.source, data.password, data.docBaseUrl);
        var doc = new _pdf.PDFDocument(pdfManager, data.source.docId);
        doc.serializable = sink;
        doc.getDownloadInfo().then(function (downloadInfo) {
          handler.send("GetDoc", {
            downloadInfo: downloadInfo
          });
        });
        doc.getAttachments().then(function (attachments) {
          handler.send("GetAttachments", {
            attachments: attachments
          });
        });
        doc.getJavaScript().then(function (javaScript) {
          handler.send("GetJavaScript", {
            javaScript: javaScript
          });
        });
        doc.getMetadata().then(function (data) {
          handler.send("Metadata", {
            metadata: data.metadata,
            info: data.info,
            contentDispositionFilename: data.contentDispositionFilename
          });
        });
        doc.getOutline().then(function (outline) {
          handler.send("GetOutline", {
            outline: outline
          });
        });
        doc.getPermissions().then(function (permissions) {
          handler.send("GetPermissions", {
            permissions: permissions
          });
        });
        doc.getOptionalContentConfig().then(function (optionalContentConfig) {
          handler.send("GetOptionalContentConfig", {
            optionalContentConfig: optionalContentConfig
          });
        });
        doc.getXfa().then(function (xfa) {
          handler.send("GetXfa", {
            xfa: xfa
          });
        });
        doc.getDestinations().then(function (destinations) {
          handler.send("GetDestinations", {
            destinations: destinations
          });
        });
      });
      handler.on("GetData", function (data, sink) {
        _pdf.PDFDocument.fromId(data.docId).then(function (doc) {
          doc.getData(sink);
        });
      });
      handler.on("GetPage", function (data) {
        _pdf.PDFDocument.fromId(data.docId).then(function (doc) {
          return doc.getPage(data.pageIndex).then(function (page) {
            Promise.all([page.getOperatorList({
              intent: data.intent,
              cacheKey: data.cacheKey
            }), page.getViewport({
              scale: 1,
              rotation: data.rotate
            })]).then(function (results) {
              handler.send("Page", {
                pageIndex: data.pageIndex,
                operatorList: results[0],
                rotate: data.rotate,
                view: results[1].view,
                ref: page.ref,
                intent: data.intent,
                cacheKey: data.cacheKey
              });
            }).catch(function (reason) {
              if (reason instanceof _util.RenderingCancelledException) {
                handler.send("PageCancelled", {
                  pageIndex: data.pageIndex,
                  intent: data.intent,
                  cacheKey: data.cacheKey
                });
                return;
              }
              handler.send("PageError", {
                pageIndex: data.pageIndex,
                error: reason,
                intent: data.intent,
                cacheKey: data.cacheKey
              });
            });
          });
        });
      });
      handler.on("GetPageLabels", function (data) {
        _pdf.PDFDocument.fromId(data.docId).then(function (doc) {
          var labels = doc.getPageLabels();
          handler.send("PageLabels", {
            labels: labels
          });
        });
      });
      handler.on("GetPageIndex", function (data) {
        _pdf.PDFDocument.fromId(data.docId).then(function (doc) {
          try {
            var pageIndex = doc.getPageIndex(data.ref);
            handler.send("PageIndex", {
              ref: data.ref,
              pageIndex: pageIndex
            });
          } catch (ex) {
            handler.send("PageIndex", {
              ref: data.ref,
              error: ex
            });
          }
        });
      });
      handler.on("GetAnnotations", function (data) {
        _pdf.PDFDocument.fromId(data.docId).then(function (doc) {
          doc.getPage(data.pageIndex).then(function (page) {
            page.getAnnotationsData(data.intent).then(function (annotations) {
              handler.send("Annotations", {
                pageIndex: data.pageIndex,
                annotations: annotations,
                intent: data.intent
              });
            });
          });
        });
      });
      handler.on("GetStructTree", function (data) {
        _pdf.PDFDocument.fromId(data.docId).then(function (doc) {
          doc.getStructTree().then(function (structTree) {
            handler.send("StructTree", {
              structTree: structTree
            });
          });
        });
      });
      handler.on("GetTextContent", function (data, sink) {
        _pdf.PDFDocument.fromId(data.docId).then(function (doc) {
          doc.getPage(data.pageIndex).then(function (page) {
            page.extractTextContent(data.normalizeWhitespace, data.combineTextItems).then(function (textContent) {
              handler.send("TextContent", {
                pageIndex: data.pageIndex,
                textContent: textContent
              });
              sink.close();
            }, function (reason) {
              sink.error(reason);
            });
          });
        });
      });
      handler.on("FontFallback", function (data) {
        _pdf.PDFDocument.fromId(data.docId).then(function (doc) {
          doc.fontFallback(data.id, handler);
        });
      });
      handler.on("Cleanup", function (data) {
        _pdf.PDFDocument.cleanup(data.docId);
      });
    }
  }, {
    key: "create",
    value: function create(handler) {
      if (_is_node.isNodeJS) {
        var _require = __webpack_require__(11),
          Worker = _require.Worker;
        var worker = new Worker(__filename, {
          name: "PDF.js",
          workerData: {
            isWorker: true
          }
        });
        var port = worker;
        this.setup(handler, port);
        return worker;
      }
      var script = "self.pdfWorker = true; self.importScripts(\"".concat(PDFJSDev.eval("BUNDLE_SRC"), "\");");
      var worker = new Worker(URL.createObjectURL(new Blob([script], {
        type: "application/javascript"
      })), {
        name: "PDF.js"
      });
      this.setup(handler, worker);
      return worker;
    }
  }, {
    key: "sendWithPromise",
    value: function sendWithPromise(name, data, transfers) {
      var _this2 = this;
      return new Promise(function (resolve) {
        var eventName = "worker" + name;
        var KEEPSENDING = true;
        varDone = false;
        var handler = function handler(type, args) {
          if (type !== "done") {
            resolve(args);
          } else {
            varDone = true;
          }
          if (KEEPSENDING && varDone) {
            self.removeEventListener(eventName, handler);
          }
        };
        self.addEventListener(eventName, handler);
        try {
          if (_is_node.isNodeJS) {
            var _require2 = __webpack_require__(11),
              parentPort = _require2.parentPort;
            parentPort.postMessage({
              source: "worker",
              target: "main",
              name: name,
              data: data,
              port: null
            });
          } else {
            self.postMessage({
              source: "worker",
              target: "main",
              name: name,
              data: data,
              port: null
            }, transfers);
          }
        } catch (ex) {
          KEEPSENDING = false;
          _this2.fallback(resolve, ex);
        }
      });
    }
  }, {
    key: "fallback",
    value: function fallback(resolve, error) {
      if (error && error.name === "DataCloneError" && error.message.includes("could not be cloned")) {
        resolve({
          success: false,
          name: "DataCloneError",
          message: error.message
        });
      } else {
        resolve({
          success: false,
          name: "UnknownError",
          message: "An unknown error occurred in the worker."
        });
      }
    }
  }]);
  return WorkerMessageHandler;
}();
exports.WorkerMessageHandler = WorkerMessageHandler;
function initializeWorker() {
  var handler = {
    on: function on(name, listener) {
      var _this3 = this;
      var KEEPSENDING = true;
      var oname = "main" + name;
      var ah = function ah(event) {
        if (!event.data.target || event.data.target !== "worker") {
          return;
        }
        var source = event.data.source;
        var listenerName = name;
        if (source) {
          listenerName = source + listenerName;
        }
        if (event.data.name !== listenerName) {
          return;
        }
        var sink = {
          postMessage: function postMessage(data, transfers) {
            var _this4 = this;
            return new Promise(function (resolve, reject) {
              var eventName = "worker" + name;
              self.addEventListener(eventName, function handler(event) {
                var eventName = event.data.name;
                var source = event.data.source;
                var type = event.data.type;
                if (source) {
                  eventName = source + eventName;
                }
                if (eventName !== listenerName || type !== "ready") {
                  return;
                }
                self.removeEventListener(eventName, handler);
                resolve();
              });
              try {
                if (_is_node.isNodeJS) {
                  var _require3 = __webpack_require__(11),
                    parentPort = _require3.parentPort;
                  parentPort.postMessage({
                    source: "worker",
                    target: source,
                    name: listenerName,
                    data: data,
                    type: "data"
                  });
                } else {
                  self.postMessage({
                    source: "worker",
                    target: source,
                    name: listenerName,
                    data: data,
                    type: "data"
                  }, transfers);
                }
              } catch (ex) {
                KEEPSENDING = false;
                _this4.fallback(resolve, ex);
              }
            });
          },
          onpull: null,
          oncancel: null,
          close: function close() {
            var eventName = "worker" + name;
            self.addEventListener(eventName, function handler(event) {
              var eventName = event.data.name;
              var source = event.data.source;
              var type = event.data.type;
              if (source) {
                eventName = source + eventName;
              }
              if (eventName !== listenerName || type !== "close") {
                return;
              }
              self.removeEventListener(eventName, handler);
            });
            if (_is_node.isNodeJS) {
              var _require4 = __webpack_require__(11),
                parentPort = _require4.parentPort;
              parentPort.postMessage({
                source: "worker",
                target: source,
                name: listenerName,
                type: "close"
              });
            } else {
              self.postMessage({
                source: "worker",
                target: source,
                name: listenerName,
                type: "close"
              });
            }
          },
          error: function error(reason) {
            var eventName = "worker" + name;
            self.addEventListener(eventName, function handler(event) {
              var eventName = event.data.name;
              var source = event.data.source;
              var type = event.data.type;
              if (source) {
                eventName = source + eventName;
              }
              if (eventName !== listenerName || type !== "error") {
                return;
              }
              self.removeEventListener(eventName, handler);
            });
            if (_is_node.isNodeJS) {
              var _require5 = __webpack_require__(11),
                parentPort = _require5.parentPort;
              parentPort.postMessage({
                source: "worker",
                target: source,
                name: listenerName,
                data: reason,
                type: "error"
              });
            } else {
              self.postMessage({
                source: "worker",
                target: source,
                name: listenerName,
                data: reason,
                type: "error"
              });
            }
          }
        };
        var port = event.data.port;
        if (port) {
          port.onmessage = function (event) {
            if (event.data.name === "pull") {
              sink.onpull();
            } else if (event.data.name === "cancel") {
              sink.oncancel(event.data.reason);
            }
          };
        }
        var removeAllListeners = function removeAllListeners() {
          self.removeEventListener(oname, ah);
        };
        var result = listener(event.data.data, sink, removeAllListeners);
        if (_typeof(result) === "object" && result !== null && typeof result.then === "function") {
          result.then(function () {
            if (KEEPSENDING) {
              self.postMessage({
                source: "worker",
                target: "main",
                name: oname + "complete",
                data: event.data.data,
                port: null
              });
            }
          });
        }
      };
      self.addEventListener("message", ah);
    },
    send: function send(name, data, transfers) {
      setTimeout(function () {
        try {
          if (_is_node.isNodeJS) {
            var _require6 = __webpack_require__(11),
              parentPort = _require6.parentPort;
            parentPort.postMessage({
              source: "worker",
              target: "main",
              name: name,
              data: data
            }, transfers);
          } else {
            self.postMessage({
              source: "worker",
              target: "main",
              name: name,
              data: data
            }, transfers);
          }
        } catch (ex) {
          console.error("Cannot send '".concat(name, "' message from worker: ").concat(ex));
        }
      }, 0);
    }
  };
  WorkerMessageHandler.setup(handler, self);
}
if ((typeof PDFJSDev === "undefined" || PDFJSDev.test("WORKER")) && (isNodeJS ? module.parent.workerData.isWorker : self.pdfWorker)) {
  initializeWorker();
}

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFManager = exports.PDFDocument = void 0;
var _util = __webpack_require__(1);
var _util_metapdf = __webpack_require__(4);
var _core_utils = __webpack_require__(5);
var _primitives = __webpack_require__(6);
var _stream = __webpack_require__(7);
var _parser = __webpack_require__(8);
var _crypto = __webpack_require__(9);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var Page = function () {
  function Page(_ref) {
    var pdfManager = _ref.pdfManager,
      xref = _ref.xref,
      pageIndex = _ref.pageIndex,
      pageDict = _ref.pageDict,
      ref = _ref.ref,
      fontCache = _ref.fontCache,
      builtInCMapCache = _ref.builtInCMapCache;
    _classCallCheck(this, Page);
    this.pdfManager = pdfManager;
    this.pageIndex = pageIndex;
    this.pageDict = pageDict;
    this.xref = xref;
    this.ref = ref;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.intentStates = new Map();
  }
  _createClass(Page, [{
    key: "rotate",
    get: function get() {
      var rotate = this.pageDict.get("Rotate") || 0;
      if (rotate % 90 !== 0) {
        rotate = 0;
      } else if (rotate >= 360) {
        rotate = rotate % 360;
      } else if (rotate < 0) {
        rotate = (rotate % 360 + 360) % 360;
      }
      return (0, _util.shadow)(this, "rotate", rotate);
    }
  }, {
    key: "userUnit",
    get: function get() {
      var userUnit = this.pageDict.get("UserUnit");
      if (!Number.isFinite(userUnit) || userUnit <= 0) {
        userUnit = 1;
      }
      return (0, _util.shadow)(this, "userUnit", userUnit);
    }
  }, {
    key: "view",
    get: function get() {
      var cropBox = this.pageDict.get("CropBox");
      var mediaBox = this.pageDict.get("MediaBox");
      if (!Array.isArray(cropBox) || cropBox.length !== 4) {
        return (0, _util.shadow)(this, "view", mediaBox);
      }
      var intersection = _util.Util.intersect(cropBox, mediaBox);
      if (!intersection) {
        (0, _util.warn)("Empty /CropBox and /MediaBox intersection.");
        return (0, _util.shadow)(this, "view", mediaBox);
      }
      return (0, _util.shadow)(this, "view", intersection);
    }
  }, {
    key: "getViewport",
    value: function getViewport() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$scale = _ref2.scale,
        scale = _ref2$scale === void 0 ? 1 : _ref2$scale,
        _ref2$rotation = _ref2.rotation,
        rotation = _ref2$rotation === void 0 ? this.rotate : _ref2$rotation,
        _ref2$offsetX = _ref2.offsetX,
        offsetX = _ref2$offsetX === void 0 ? 0 : _ref2$offsetX,
        _ref2$offsetY = _ref2.offsetY,
        offsetY = _ref2$offsetY === void 0 ? 0 : _ref2$offsetY,
        _ref2$dontFlip = _ref2.dontFlip,
        dontFlip = _ref2$dontFlip === void 0 ? false : _ref2$dontFlip;
      var _this$view = this.view,
        x1 = _this$view[0],
        y1 = _this$view[1],
        x2 = _this$view[2],
        y2 = _this$view[3];
      var pageRotation = (this.rotate + rotation) % 360;
      var width = x2 - x1;
      var height = y2 - y1;
      var viewportWidth, viewportHeight;
      if (pageRotation === 90 || pageRotation === 270) {
        viewportWidth = height;
        viewportHeight = width;
      } else {
        viewportWidth = width;
        viewportHeight = height;
      }
      var transform;
      switch (pageRotation) {
        case 0:
          transform = [1, 0, 0, -1, -x1, y2];
          break;
        case 90:
          transform = [0, 1, -1, 0, y2, -x1];
          break;
        case 180:
          transform = [-1, 0, 0, 1, x2, -y1];
          break;
        case 270:
          transform = [0, -1, 1, 0, -y1, x2];
          break;
        default:
          throw new Error("Invalid page rotation");
      }
      if (this.userUnit !== 1) {
        scale *= this.userUnit;
      }
      var viewportTransform;
      if (dontFlip) {
        transform[1] = -transform[1];
        transform[3] = -transform[3];
        transform[5] = -transform[5];
        viewportTransform = [scale, 0, 0, scale, offsetX, offsetY];
      } else {
        viewportTransform = [scale, 0, 0, -scale, offsetX, offsetY];
      }
      viewportTransform = _util.Util.transform(viewportTransform, [1, 0, 0, 1, 0, -viewportHeight]);
      var vp = {
        width: viewportWidth * scale,
        height: viewportHeight * scale,
        scale: scale,
        rotation: rotation,
        offsetX: offsetX,
        offsetY: offsetY,
        transform: _util.Util.transform(viewportTransform, transform),
        viewBox: [0, 0, viewportWidth, viewportHeight]
      };
      return new _core_utils.PageViewport(vp);
    }
  }, {
    key: "_getAnnotations",
    value: function _getAnnotations(intent) {
      var _this = this;
      return this.pdfManager.ensure(this, "getAnnotationsData", [intent]).then(function () {
        return _this.annotations;
      });
    }
  }, {
    key: "getAnnotations",
    value: function getAnnotations() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$intent = _ref3.intent,
        intent = _ref3$intent === void 0 ? "display" : _ref3$intent;
      if (this.annotationsPromise && this.annotationsIntent === intent) {
        return this.annotationsPromise;
      }
      this.annotationsIntent = intent;
      return this.annotationsPromise = _core_utils.AnnotationFactory.createAnnotations(this.pageDict, this.xref, this.pdfManager, this.builtInCMapCache, intent);
    }
  }, {
    key: "getAnnotationsData",
    value: function getAnnotationsData(intent) {
      if (this.annotationsDataPromise && this.annotationsDataIntent === intent) {
        return this.annotationsDataPromise;
      }
      this.annotationsDataIntent = intent;
      return this.annotationsDataPromise = this.getAnnotations({
        intent: intent
      }).then(function (annotations) {
        var annotationsData = [];
        for (var i = 0, ii = annotations.length; i < ii; ++i) {
          annotationsData.push(annotations[i].data);
        }
        return annotationsData;
      });
    }
  }, {
    key: "getOperatorList",
    value: function getOperatorList() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$intent = _ref4.intent,
        intent = _ref4$intent === void 0 ? "display" : _ref4$intent,
        _ref4$cacheKey = _ref4.cacheKey,
        cacheKey = _ref4$cacheKey === void 0 ? "" : _ref4$cacheKey;
      var state = this.intentStates.get(intent);
      if (!state) {
        state = {
          opListPromise: null,
          opListCache: Object.create(null),
          lastQueue: null
        };
        this.intentStates.set(intent, state);
      }
      if (cacheKey && state.opListCache[cacheKey]) {
        return state.opListCache[cacheKey];
      }
      var self = this;
      var lastQueue = state.lastQueue;
      function getAnnotations() {
        return self._getAnnotations(intent);
      }
      function getOperatorList(annotations) {
        var data = {
          xref: self.xref,
          pageDict: self.pageDict,
          annotations: annotations,
          intent: intent,
          fontCache: self.fontCache,
          builtInCMapCache: self.builtInCMapCache,
          pdfManager: self.pdfManager
        };
        var task = new _core_utils.OperatorList(intent, _core_utils.isAnnots, _core_utils.isXFA, data);
        state.opListPromise = task.getOperatorList(self.pageDict, self.xref);
        return state.opListPromise;
      }
      if (lastQueue) {
        var queue = lastQueue.queue;
        queue.push(getAnnotations, getOperatorList);
        state.lastQueue = queue;
        return state.opListPromise;
      }
      var _queue = new _core_utils.PromiseQueue();
      _queue.push(getAnnotations, getOperatorList);
      state.lastQueue = _queue;
      return state.opListPromise.finally(function () {
        state.opListPromise = null;
        state.lastQueue = null;
      });
    }
  }, {
    key: "extractTextContent",
    value: function extractTextContent() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref5$normalizeWhite = _ref5.normalizeWhitespace,
        normalizeWhitespace = _ref5$normalizeWhite === void 0 ? false : _ref5$normalizeWhite,
        _ref5$combineTextIte = _ref5.combineTextItems,
        combineTextItems = _ref5$combineTextIte === void 0 ? false : _ref5$combineTextIte,
        _ref5$includeImage = _ref5.includeImage,
        includeImage = _ref5$includeImage === void 0 ? false : _ref5$includeImage;
      return this.getOperatorList({
        intent: "display"
      }).then(function (opList) {
        var textContent = (0, _core_utils.getTextContent)(opList, normalizeWhitespace, combineTextItems, includeImage);
        return textContent;
      });
    }
  }, {
    key: "getStructTree",
    value: function getStructTree() {
      return this.pdfManager.ensure(this.pdfManager, "getStructTree").then(function (structTree) {
        if (!structTree) {
          return null;
        }
        return structTree.getTree(this);
      }.bind(this));
    }
  }]);
  return Page;
}();
var structTreeBuilder = null;
var PDFDocument = function (_util_metapdf$MetaPDF) {
  _inherits(PDFDocument, _util_metapdf$MetaPDF);
  var _super = _createSuper(PDFDocument);
  function PDFDocument(pdfManager, docId) {
    var _this2;
    _classCallCheck(this, PDFDocument);
    _this2 = _super.call(this, {
      pdfManager: pdfManager,
      docId: docId
    });
    _this2.pdfInfo = pdfManager.pdfDocument.pdfInfo;
    _this2.xref = _this2.pdfInfo.xref;
    _this2.catalog = _this2.pdfInfo.catalog;
    _this2.fontCache = new _primitives.RefSetCache();
    _this2.builtInCMapCache = new Map();
    _this2.standardFontDataCache = new Map();
    _this2.pagePromises = [];
    var doc = PDFDocument.getDoc(docId);
    if (doc) {
      doc.destroy();
    }
    PDFDocument.addDoc(docId, _assertThisInitialized(_this2));
    return _this2;
  }
  _createClass(PDFDocument, [{
    key: "numPages",
    get: function get() {
      return this.catalog.numPages;
    }
  }, {
    key: "fingerprint",
    get: function get() {
      var fingerprint = "";
      var fileID = this.xref.trailer.get("ID");
      if (Array.isArray(fileID) && typeof fileID[0] === "string") {
        fingerprint = fileID[0];
      }
      return (0, _util.shadow)(this, "fingerprint", fingerprint);
    }
  }, {
    key: "getPage",
    value: function getPage(pageIndex) {
      if (this.pagePromises[pageIndex]) {
        return this.pagePromises[pageIndex];
      }
      var promise = this.catalog.getPage(pageIndex).then(function (pageDict) {
        var pageRef = this.catalog.getPageRef(pageIndex);
        return new Page({
          pdfManager: this.pdfManager,
          xref: this.xref,
          pageIndex: pageIndex,
          pageDict: pageDict,
          ref: pageRef,
          fontCache: this.fontCache,
          builtInCMapCache: this.builtInCMapCache
        });
      }.bind(this));
      this.pagePromises[pageIndex] = promise;
      return promise;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.pdfManager) {
        return;
      }
      this.pdfManager.terminate();
      this.pdfManager = null;
      PDFDocument.removeDoc(this.id);
    }
  }, {
    key: "getAttachments",
    value: function getAttachments() {
      var _this3 = this;
      return this.pdfManager.ensure(this, "getAttachments").then(function () {
        return _this3.attachments;
      });
    }
  }, {
    key: "getJavaScript",
    value: function getJavaScript() {
      var _this4 = this;
      return this.pdfManager.ensure(this, "getJavaScript").then(function () {
        return _this4.javaScript;
      });
    }
  }, {
    key: "getOutline",
    value: function getOutline() {
      var _this5 = this;
      return this.pdfManager.ensure(this, "getOutline").then(function () {
        return _this5.outline;
      });
    }
  }, {
    key: "getPermissions",
    value: function getPermissions() {
      var _this6 = this;
      return this.pdfManager.ensure(this, "getPermissions").then(function () {
        return _this6.permissions;
      });
    }
  }, {
    key: "getOptionalContentConfig",
    value: function getOptionalContentConfig() {
      var _this7 = this;
      return this.pdfManager.ensure(this, "getOptionalContentConfig").then(function (optionalContentConfig) {
        return _this7.optionalContentConfig;
      });
    }
  }, {
    key: "getPageMode",
    value: function getPageMode() {
      var _this8 = this;
      return this.pdfManager.ensure(this, "getPageMode").then(function () {
        return _this8.pageMode;
      });
    }
  }, {
    key: "fontFallback",
    value: function fontFallback(id, handler) {
      return this.pdfManager.fontFallback(id, handler);
    }
  }, {
    key: "getStructTree",
    value: function getStructTree() {
      return this.pdfManager.ensure(this.pdfManager, "getStructTree");
    }
  }], [{
    key: "fromId",
    value: function fromId(docId) {
      return Promise.resolve(this.getDoc(docId));
    }
  }, {
    key: "addDoc",
    value: function addDoc(docId, doc) {
      if (!this.docs) {
        this.docs = Object.create(null);
      }
      this.docs[docId] = doc;
    }
  }, {
    key: "getDoc",
    value: function getDoc(docId) {
      return this.docs ? this.docs[docId] || null : null;
    }
  }, {
    key: "removeDoc",
    value: function removeDoc(docId) {
      if (this.docs) {
        delete this.docs[docId];
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup(docId) {
      _core_utils.Font.clearCache();
      (0, _util.clearPrimitiveCaches)();
      if (!docId) {
        return;
      }
      var doc = this.getDoc(docId);
      if (doc) {
        doc.destroy();
      }
    }
  }]);
  return PDFDocument;
}(_util_metapdf.MetaPDFDocument);
exports.PDFDocument = PDFDocument;
var PDFManager = function () {
  function PDFManager(owner, source, password, docBaseUrl) {
    _classCallCheck(this, PDFManager);
    this.owner = owner;
    this.source = source;
    this.password = password;
    this.docBaseUrl = docBaseUrl;
    var stream = source.stream;
    this.pdfDocument = new _parser.PDFDocumentParser({
      stream: stream,
      owner: this,
      xref: null,
      password: password,
      docBaseUrl: docBaseUrl
    });
    this._loadedStreamCapability = (0, _util.createPromiseCapability)();
  }
  _createClass(PDFManager, [{
    key: "ensure",
    value: function ensure(obj, prop, args) {
      var _this9 = this;
      return new Promise(function (resolve, reject) {
        _this9.request(function () {
          try {
            var value = obj[prop];
            if (typeof value === "function") {
              value.apply(obj, args).then(resolve, reject);
            } else {
              resolve(value);
            }
          } catch (e) {
            reject(e);
          }
        });
      });
    }
  }, {
    key: "request",
    value: function request(fn) {
      this.pdfDocument.xref.parser.send(fn);
    }
  }, {
    key: "getDestinations",
    value: function getDestinations() {
      return this.pdfDocument.getDestinations();
    }
  }, {
    key: "getAttachments",
    value: function getAttachments() {
      return this.pdfDocument.getAttachments();
    }
  }, {
    key: "getJavaScript",
    value: function getJavaScript() {
      return this.pdfDocument.getJavaScript();
    }
  }, {
    key: "getOutline",
    value: function getOutline() {
      return this.pdfDocument.getOutline();
    }
  }, {
    key: "getPermissions",
    value: function getPermissions() {
      return this.pdfDocument.getPermissions();
    }
  }, {
    key: "getOptionalContentConfig",
    value: function getOptionalContentConfig() {
      return this.pdfDocument.getOptionalContentConfig();
    }
  }, {
    key: "getStructTree",
    value: function getStructTree() {
      if (structTreeBuilder) {
        return Promise.resolve(structTreeBuilder);
      }
      var promise = this.pdfDocument.getStructTree();
      promise.then(function (tree) {
        if (!tree) {
          return;
        }
        structTreeBuilder = new _core_utils.StructTreeBuilder(tree);
      });
      return promise;
    }
  }, {
    key: "terminate",
    value: function terminate() {
      this.pdfDocument.destroy();
    }
  }, {
    key: "fontFallback",
    value: function fontFallback(id, handler) {
      this.pdfDocument.fontFallback(id, handler);
    }
  }]);
  return PDFManager;
}();
exports.PDFManager = PDFManager;

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MetaPDFDocument = void 0;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var MetaPDFDocument = function () {
  function MetaPDFDocument(_ref) {
    var pdfManager = _ref.pdfManager,
      docId = _ref.docId;
    _classCallCheck(this, MetaPDFDocument);
    this.pdfManager = pdfManager;
    this.id = docId;
    this._doc = pdfManager.pdfDocument;
    this._capability = (0, util.createPromiseCapability)();
  }
  _createClass(MetaPDFDocument, [{
    key: "_transport",
    get: function get() {
      return this.pdfManager.transport;
    }
  }, {
    key: "pageLabels",
    get: function get() {
      return this._doc.catalog.pageLabels;
    }
  }, {
    key: "numPages",
    get: function get() {
      return this._doc.numPages;
    }
  }, {
    key: "getPageLabels",
    value: function getPageLabels() {
      return this._doc.catalog.getPageLabels();
    }
  }, {
    key: "getPageIndex",
    value: function getPageIndex(ref) {
      var pageIndex = this._doc.catalog.getPageIndex(ref);
      if (pageIndex === -1) {
        return -1;
      }
      return pageIndex;
    }
  }, {
    key: "getDestinations",
    value: function getDestinations() {
      return this.pdfManager.getDestinations();
    }
  }, {
    key: "getAttachments",
    value: function getAttachments() {
      return this.pdfManager.getAttachments();
    }
  }, {
    key: "getJavaScript",
    value: function getJavaScript() {
      return this.pdfManager.getJavaScript();
    }
  }, {
    key: "getOutline",
    value: function getOutline() {
      return this.pdfManager.getOutline();
    }
  }, {
    key: "getPermissions",
    value: function getPermissions() {
      return this.pdfManager.getPermissions();
    }
  }, {
    key: "getMetadata",
    value: function getMetadata() {
      return this.pdfManager.getMetadata();
    }
  }, {
    key: "getDownloadInfo",
    value: function getDownloadInfo() {
      return this.pdfManager.getDownloadInfo();
    }
  }, {
    key: "getData",
    value: function getData() {
      var _this = this;
      var capability = (0, util.createPromiseCapability)();
      this.pdfManager.request(function () {
        capability.resolve(_this._doc.getData());
      });
      return capability.promise;
    }
  }, {
    key: "getOptionalContentConfig",
    value: function getOptionalContentConfig() {
      return this.pdfManager.getOptionalContentConfig();
    }
  }, {
    key: "getXfa",
    value: function getXfa() {
      return this.pdfManager.getXfa();
    }
  }, {
    key: "cleanup",
    value: function cleanup(manuallyTriggered) {
      if (this.pdfManager.terminated) {
        return;
      }
      this.pdfManager.terminate(manuallyTriggered);
    }
  }]);
  return MetaPDFDocument;
}();
exports.MetaPDFDocument = MetaPDFDocument;

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isXFA = exports.isAnnots = exports.StructTreeBuilder = exports.TextContent = exports.PromiseQueue = exports.PageViewport = exports.OperatorList = exports.OptionalContentGroup = exports.Font = exports.AnnotationFactory = void 0;
exports.extractMatrix = extractMatrix;
exports.getInheritableProperty = getInheritableProperty;
exports.getTextContent = getTextContent;
exports.isEmptyStream = isEmptyStream;
var _util = __webpack_require__(1);
var _primitives = __webpack_require__(6);
var _stream = __webpack_require__(7);
var _parser = __webpack_require__(8);
var _crypto = __webpack_require__(9);
var _bidi = __webpack_require__(12);
var _colorspace = __webpack_require__(13);
var _core_pattern = __webpack_require__(14);
var _image_utils = __webpack_require__(15);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var PageViewport = function () {
  function PageViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$viewBox = _ref.viewBox,
      viewBox = _ref$viewBox === void 0 ? [0, 0, 1, 1] : _ref$viewBox,
      _ref$scale = _ref.scale,
      scale = _ref$scale === void 0 ? 1 : _ref$scale,
      _ref$rotation = _ref.rotation,
      rotation = _ref$rotation === void 0 ? 0 : _ref$rotation,
      _ref$offsetX = _ref.offsetX,
      offsetX = _ref$offsetX === void 0 ? 0 : _ref$offsetX,
      _ref$offsetY = _ref.offsetY,
      offsetY = _ref$offsetY === void 0 ? 0 : _ref$offsetY,
      _ref$dontFlip = _ref.dontFlip,
      dontFlip = _ref$dontFlip === void 0 ? false : _ref$dontFlip,
      _ref$transform = _ref.transform,
      transform = _ref$transform === void 0 ? _util.FONT_IDENTITY_MATRIX : _ref$transform;
    _classCallCheck(this, PageViewport);
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    this.transform = transform;
    var _this$viewBox = this.viewBox,
      x1 = _this$viewBox[0],
      y1 = _this$viewBox[1],
      x2 = _this$viewBox[2],
      y2 = _this$viewBox[3];
    var width = x2 - x1;
    var height = y2 - y1;
    if (dontFlip) {
      if (this.rotation === 90 || this.rotation === 270) {
        this.width = height * this.scale;
        this.height = width * this.scale;
      } else {
        this.width = width * this.scale;
        this.height = height * this.scale;
      }
    } else {
      this.width = width * this.scale;
      this.height = height * this.scale;
    }
  }
  _createClass(PageViewport, [{
    key: "clone",
    value: function clone() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$scale = _ref2.scale,
        scale = _ref2$scale === void 0 ? this.scale : _ref2$scale,
        _ref2$rotation = _ref2.rotation,
        rotation = _ref2$rotation === void 0 ? this.rotation : _ref2$rotation,
        _ref2$offsetX = _ref2.offsetX,
        offsetX = _ref2$offsetX === void 0 ? this.offsetX : _ref2$offsetX,
        _ref2$offsetY = _ref2.offsetY,
        offsetY = _ref2$offsetY === void 0 ? this.offsetY : _ref2$offsetY,
        _ref2$dontFlip = _ref2.dontFlip,
        dontFlip = _ref2$dontFlip === void 0 ? false : _ref2$dontFlip,
        _ref2$transform = _ref2.transform,
        transform = _ref2$transform === void 0 ? null : _ref2$transform;
      return new PageViewport({
        viewBox: this.viewBox.slice(),
        scale: scale,
        rotation: rotation,
        offsetX: offsetX,
        offsetY: offsetY,
        dontFlip: dontFlip,
        transform: transform ? transform.slice() : this.transform.slice()
      });
    }
  }, {
    key: "convertToViewportPoint",
    value: function convertToViewportPoint(x, y) {
      return _util.Util.applyTransform([x, y], this.transform);
    }
  }, {
    key: "convertToViewportRectangle",
    value: function convertToViewportRectangle(rect) {
      var tl = _util.Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = _util.Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    }
  }, {
    key: "convertToPdfPoint",
    value: function convertToPdfPoint(x, y) {
      return _util.Util.applyInverseTransform([x, y], this.transform);
    }
  }]);
  return PageViewport;
}();
exports.PageViewport = PageViewport;
var AnnotationFactory = function () {
  function AnnotationFactory() {
    _classCallCheck(this, AnnotationFactory);
  }
  _createClass(AnnotationFactory, null, [{
    key: "createAnnotations",
    value: function createAnnotations(pageDict, xref, pdfManager, builtInCMapCache, intent) {
      return pdfManager.ensure(pageDict, "get", ["Annots"]).then(function (annots) {
        if (!Array.isArray(annots)) {
          return [];
        }
        var annotations = [];
        var _iterator = _createForOfIteratorHelper(annots),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var annot = _step.value;
            var annotDict = (0, _primitives.isRef)(annot) ? xref.fetch(annot) : annot;
            if (!(0, _primitives.isDict)(annotDict)) {
              continue;
            }
            var data = {
              annotationObject: annotDict,
              xref: xref,
              pdfManager: pdfManager,
              builtInCMapCache: builtInCMapCache,
              intent: intent
            };
            var annotation = AnnotationFactory.create(data);
            if (annotation) {
              annotations.push(annotation);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return annotations;
      });
    }
  }, {
    key: "create",
    value: function create(data) {
      var subtype = data.annotationObject.get("Subtype");
      var Ctor;
      switch (subtype) {
        case _primitives.Name.get("Link"):
          Ctor = LinkAnnotation;
          break;
        case _primitives.Name.get("Text"):
          Ctor = TextAnnotation;
          break;
        case _primitives.Name.get("Widget"):
          Ctor = WidgetAnnotation;
          break;
        case _primitives.Name.get("Popup"):
          Ctor = PopupAnnotation;
          break;
        case _primitives.Name.get("FreeText"):
          Ctor = FreeTextAnnotation;
          break;
        case _primitives.Name.get("Line"):
          Ctor = LineAnnotation;
          break;
        case _primitives.Name.get("Square"):
          Ctor = SquareAnnotation;
          break;
        case _primitives.Name.get("Circle"):
          Ctor = CircleAnnotation;
          break;
        case _primitives.Name.get("PolyLine"):
          Ctor = PolylineAnnotation;
          break;
        case _primitives.Name.get("Polygon"):
          Ctor = PolygonAnnotation;
          break;
        case _primitives.Name.get("Caret"):
          Ctor = CaretAnnotation;
          break;
        case _primitives.Name.get("Ink"):
          Ctor = InkAnnotation;
          break;
        case _primitives.Name.get("Highlight"):
          Ctor = HighlightAnnotation;
          break;
        case _primitives.Name.get("Underline"):
          Ctor = UnderlineAnnotation;
          break;
        case _primitives.Name.get("Squiggly"):
          Ctor = SquigglyAnnotation;
          break;
        case _primitives.Name.get("StrikeOut"):
          Ctor = StrikeOutAnnotation;
          break;
        case _primitives.Name.get("Stamp"):
          Ctor = StampAnnotation;
          break;
        case _primitives.Name.get("FileAttachment"):
          Ctor = FileAttachmentAnnotation;
          break;
        default:
          (0, _util.warn)('Unimplemented annotation type "' + subtype.name + '"');
          Ctor = Annotation;
          break;
      }
      return new Ctor(data);
    }
  }]);
  return AnnotationFactory;
}();
exports.AnnotationFactory = AnnotationFactory;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function getInheritableProperty(dict, name) {
  var value = dict.get(name);
  if (value) {
    return value;
  }
  var parent = dict.get("Parent");
  if ((0, _primitives.isDict)(parent)) {
    return getInheritableProperty(parent, name);
  }
  return null;
}
function extractMatrix(arr) {
  if (Array.isArray(arr) && arr.length === 6) {
    return arr;
  }
  var matrix = new Array(6);
  matrix[0] = arr.get(0) || 1;
  matrix[1] = arr.get(1) || 0;
  matrix[2] = arr.get(2) || 0;
  matrix[3] = arr.get(3) || 1;
  matrix[4] = arr.get(4) || 0;
  matrix[5] = arr.get(5) || 0;
  return matrix;
}
function isEmptyStream(stream) {
  if (stream instanceof _stream.EmptyStream) {
    return true;
  }
  if (stream instanceof _stream.Stream) {
    return stream.length === 0 || stream.dict.get("Length") === 0;
  }
  return false;
}
var Annotation = function () {
  function Annotation(data) {
    _classCallCheck(this, Annotation);
    var dict = data.annotationObject;
    this.data = {
      annotationFlags: dict.get("F"),
      borderStyle: new BorderStyle(dict),
      color: dict.get("C"),
      hasAppearance: dict.has("AP"),
      id: dict.get("NM"),
      modificationDate: dict.get("M"),
      rect: dict.get("Rect"),
      subtype: dict.get("Subtype").name,
      rotation: dict.get("Rotate")
    };
  }
  _createClass(Annotation, [{
    key: "_hasFlag",
    value: function _hasFlag(flags, flag) {
      return !!(flags & flag);
    }
  }, {
    key: "_isViewable",
    value: function _isViewable(flags, intent) {
      var isPrint = intent === "print";
      return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.HIDDEN) && !(isPrint && !this._hasFlag(flags, _util.AnnotationFlag.PRINT)) && !(!isPrint && this._hasFlag(flags, _util.AnnotationFlag.NOVIEW));
    }
  }]);
  return Annotation;
}();
var LinkAnnotation = function (_Annotation) {
  _inherits(LinkAnnotation, _Annotation);
  var _super = _createSuper(LinkAnnotation);
  function LinkAnnotation(data) {
    var _this;
    _classCallCheck(this, LinkAnnotation);
    _this = _super.call(this, data);
    var a = data.annotationObject.get("A");
    var dest = data.annotationObject.get("Dest");
    var url, newWindow, destRef;
    if (a) {
      var actionDict = (0, _primitives.isRef)(a) ? data.xref.fetch(a) : a;
      if (!(0, _primitives.isDict)(actionDict)) {
        url = "";
        (0, _util.warn)("Malformed link action");
      } else {
        var actionType = actionDict.get("S");
        if (actionType.name === "URI") {
          url = actionDict.get("URI");
        } else if (actionType.name === "GoTo") {
          dest = actionDict.get("D");
        } else if (actionType.name === "GoToR") {
          var fileSpec = actionDict.get("F");
          url = fileSpec.get("F") || fileSpec.get("UF") || fileSpec.get("DOS");
          dest = actionDict.get("D");
          newWindow = actionDict.get("NewWindow") || false;
        } else if (actionType.name === "Launch") {
          var _fileSpec = actionDict.get("F");
          if ((0, _primitives.isDict)(_fileSpec)) {
            url = _fileSpec.get("F") || _fileSpec.get("UF") || _fileSpec.get("DOS");
          } else {
            url = _fileSpec;
          }
        } else {
          url = "";
          (0, _util.warn)("Unknown link action type: " + actionType.name);
        }
      }
    } else if (dest) {} else {
      url = "";
      (0, _util.warn)("Neither an action nor a destination was specified");
    }
    if (dest) {
      if ((0, _primitives.isName)(dest)) {
        dest = dest.name;
      } else if ((0, _primitives.isRef)(dest)) {
        destRef = dest;
      }
    }
    _this.data.url = url;
    _this.data.dest = dest;
    _this.data.destRef = destRef;
    _this.data.newWindow = newWindow;
    return _this;
  }
  return _createClass(LinkAnnotation);
}(Annotation);
var TextAnnotation = function (_Annotation2) {
  _inherits(TextAnnotation, _Annotation2);
  var _super2 = _createSuper(TextAnnotation);
  function TextAnnotation(data) {
    var _this2;
    _classCallCheck(this, TextAnnotation);
    _this2 = _super2.call(this, data);
    var dict = data.annotationObject;
    _this2.data.hasPopup = dict.has("Popup");
    _this2.data.name = dict.get("Name") || "Note";
    _this2.data.title = dict.get("T");
    _this2.data.contents = dict.get("Contents");
    return _this2;
  }
  return _createClass(TextAnnotation);
}(Annotation);
var WidgetAnnotation = function (_Annotation3) {
  _inherits(WidgetAnnotation, _Annotation3);
  var _super3 = _createSuper(WidgetAnnotation);
  function WidgetAnnotation(data) {
    var _this3;
    _classCallCheck(this, WidgetAnnotation);
    _this3 = _super3.call(this, data);
    var dict = data.annotationObject;
    var fieldType = getInheritableProperty(dict, "FT").name;
    _this3.data.fieldType = fieldType;
    var fieldValue = getInheritableProperty(dict, "V");
    if ((0, _primitives.isName)(fieldValue)) {
      fieldValue = fieldValue.name;
    }
    _this3.data.fieldValue = fieldValue;
    var MK = dict.get("MK");
    var CA, BC, BG;
    if ((0, _primitives.isDict)(MK)) {
      CA = MK.get("CA");
      BC = MK.get("BC");
      BG = MK.get("BG");
    }
    _this3.data.alternativeText = CA;
    _this3.data.borderColor = BC;
    _this.data.backgroundColor = BG;
    _this3.data.textAlignment = getInheritableProperty(dict, "Q");
    _this3.data.maxLen = getInheritableProperty(dict, "MaxLen");
    _this3.data.multiLine = (dict.get("Ff") & 4096) > 0;
    _this3.data.comb = (dict.get("Ff") & 16777216) > 0;
    _this3.data.fieldName = getInheritableProperty(dict, "T");
    _this3.data.alternativeFieldName = getInheritableProperty(dict, "TU");
    _this3.data.hasRichText = !!dict.get("RC");
    switch (fieldType) {
      case "Tx":
        _this3.data.readOnly = _this3._isReadOnly(dict);
        break;
      case "Btn":
        _this3.data.pushButton = _this3._isPushButton(dict);
        _this3.data.radioButton = !_this3.data.pushButton && _this3._isRadioButton(dict);
        _this3.data.checkBox = !_this3.data.pushButton && !_this3.data.radioButton;
        break;
      case "Ch":
        _this3.data.options = _this3._getOptions(dict);
        break;
      case "Sig":
        break;
      default:
        (0, _util.warn)("Unimplemented widget field type \"".concat(fieldType, "\"."));
        break;
    }
    return _this3;
  }
  _createClass(WidgetAnnotation, [{
    key: "_isReadOnly",
    value: function _isReadOnly(dict) {
      var ff = dict.get("Ff") || 0;
      return !!(ff & 1);
    }
  }, {
    key: "_isPushButton",
    value: function _isPushButton(dict) {
      return (dict.get("Ff") || 0) & 65536;
    }
  }, {
    key: "_isRadioButton",
    value: function _isRadioButton(dict) {
      return (dict.get("Ff") || 0) & 32768;
    }
  }, {
    key: "_getOptions",
    value: function _getOptions(dict) {
      var options = [];
      var opt = dict.get("Opt");
      if (!Array.isArray(opt)) {
        return options;
      }
      for (var i = 0, ii = opt.length; i < ii; i++) {
        var option = opt[i];
        if (typeof option === "string") {
          options.push({
            exportValue: option,
            displayValue: option
          });
        } else if (Array.isArray(option)) {
          options.push({
            exportValue: option[0],
            displayValue: option[1] || option[0]
          });
        }
      }
      return options;
    }
  }]);
  return WidgetAnnotation;
}(Annotation);
var PopupAnnotation = function (_Annotation4) {
  _inherits(PopupAnnotation, _Annotation4);
  var _super4 = _createSuper(PopupAnnotation);
  function PopupAnnotation(data) {
    var _this4;
    _classCallCheck(this, PopupAnnotation);
    _this4 = _super4.call(this, data);
    var dict = data.annotationObject;
    _this4.data.title = dict.get("T");
    _this4.data.contents = dict.get("Contents");
    _this4.data.parentType = null;
    _this4.data.parentId = null;
    var parent = dict.get("Parent");
    if (parent) {
      var parentDict = (0, _primitives.isRef)(parent) ? data.xref.fetch(parent) : parent;
      if ((0, _primitives.isDict)(parentDict)) {
        _this4.data.parentType = parentDict.get("Subtype").name;
        _this4.data.parentId = parentDict.get("NM");
      }
    }
    return _this4;
  }
  return _createClass(PopupAnnotation);
}(Annotation);
var FreeTextAnnotation = function (_Annotation5) {
  _inherits(FreeTextAnnotation, _Annotation5);
  var _super5 = _createSuper(FreeTextAnnotation);
  function FreeTextAnnotation(data) {
    var _this5;
    _classCallCheck(this, FreeTextAnnotation);
    _this5 = _super5.call(this, data);
    _this5.data.fontFamily = "Helvetica";
    _this5.data.fontSize = 12;
    _this5.data.textAlignment = 0;
    _this5.data.fontColor = [0, 0, 0];
    return _this5;
  }
  return _createClass(FreeTextAnnotation);
}(Annotation);
var LineAnnotation = function (_Annotation6) {
  _inherits(LineAnnotation, _Annotation6);
  var _super6 = _createSuper(LineAnnotation);
  function LineAnnotation(data) {
    var _this6;
    _classCallCheck(this, LineAnnotation);
    _this6 = _super6.call(this, data);
    var dict = data.annotationObject;
    _this6.data.lineCoordinates = dict.get("L");
    return _this6;
  }
  return _createClass(LineAnnotation);
}(Annotation);
var SquareAnnotation = function (_Annotation7) {
  _inherits(SquareAnnotation, _Annotation7);
  var _super7 = _createSuper(SquareAnnotation);
  function SquareAnnotation(data) {
    var _this7;
    _classCallCheck(this, SquareAnnotation);
    _this7 = _super7.call(this, data);
    var dict = data.annotationObject;
    _this7.data.interiorColor = dict.get("IC");
    return _this7;
  }
  return _createClass(SquareAnnotation);
}(Annotation);
var CircleAnnotation = function (_Annotation8) {
  _inherits(CircleAnnotation, _Annotation8);
  var _super8 = _createSuper(CircleAnnotation);
  function CircleAnnotation(data) {
    var _this8;
    _classCallCheck(this, CircleAnnotation);
    _this8 = _super8.call(this, data);
    var dict = data.annotationObject;
    _this8.data.interiorColor = dict.get("IC");
    return _this8;
  }
  return _createClass(CircleAnnotation);
}(Annotation);
var PolylineAnnotation = function (_Annotation9) {
  _inherits(PolylineAnnotation, _Annotation9);
  var _super9 = _createSuper(PolylineAnnotation);
  function PolylineAnnotation(data) {
    var _this9;
    _classCallCheck(this, PolylineAnnotation);
    _this9 = _super9.call(this, data);
    var dict = data.annotationObject;
    var vertices = dict.get("Vertices");
    _this9.data.vertices = [];
    if (Array.isArray(vertices)) {
      for (var i = 0, ii = vertices.length; i < ii; i += 2) {
        _this9.data.vertices.push({
          x: vertices[i],
          y: vertices[i + 1]
        });
      }
    }
    return _this9;
  }
  return _createClass(PolylineAnnotation);
}(Annotation);
var PolygonAnnotation = function (_PolylineAnnotation) {
  _inherits(PolygonAnnotation, _PolylineAnnotation);
  var _super10 = _createSuper(PolygonAnnotation);
  function PolygonAnnotation(data) {
    var _this10;
    _classCallCheck(this, PolygonAnnotation);
    _this10 = _super10.call(this, data);
    var dict = data.annotationObject;
    _this10.data.interiorColor = dict.get("IC");
    return _this10;
  }
  return _createClass(PolygonAnnotation);
}(PolylineAnnotation);
var CaretAnnotation = function (_Annotation10) {
  _inherits(CaretAnnotation, _Annotation10);
  var _super11 = _createSuper(CaretAnnotation);
  function CaretAnnotation(data) {
    _classCallCheck(this, CaretAnnotation);
    return _super11.call(this, data);
  }
  return _createClass(CaretAnnotation);
}(Annotation);
var InkAnnotation = function (_Annotation11) {
  _inherits(InkAnnotation, _Annotation11);
  var _super12 = _createSuper(InkAnnotation);
  function InkAnnotation(data) {
    var _this11;
    _classCallCheck(this, InkAnnotation);
    _this11 = _super12.call(this, data);
    var dict = data.annotationObject;
    var inkLists = dict.get("InkList");
    _this11.data.inkLists = [];
    if (Array.isArray(inkLists)) {
      for (var i = 0, ii = inkLists.length; i < ii; i++) {
        var inkList = inkLists[i];
        var list = [];
        _this11.data.inkLists.push(list);
        for (var j = 0, jj = inkList.length; j < jj; j += 2) {
          list.push({
            x: inkList[j],
            y: inkList[j + 1]
          });
        }
      }
    }
    return _this11;
  }
  return _createClass(InkAnnotation);
}(Annotation);
var HighlightAnnotation = function (_Annotation12) {
  _inherits(HighlightAnnotation, _Annotation12);
  var _super13 = _createSuper(HighlightAnnotation);
  function HighlightAnnotation(data) {
    var _this12;
    _classCallCheck(this, HighlightAnnotation);
    _this12 = _super13.call(this, data);
    var dict = data.annotationObject;
    _this12.data.quadPoints = dict.get("QuadPoints");
    return _this12;
  }
  return _createClass(HighlightAnnotation);
}(Annotation);
var UnderlineAnnotation = function (_Annotation13) {
  _inherits(UnderlineAnnotation, _Annotation13);
  var _super14 = _createSuper(UnderlineAnnotation);
  function UnderlineAnnotation(data) {
    var _this13;
    _classCallCheck(this, UnderlineAnnotation);
    _this13 = _super14.call(this, data);
    var dict = data.annotationObject;
    _this13.data.quadPoints = dict.get("QuadPoints");
    return _this13;
  }
  return _createClass(UnderlineAnnotation);
}(Annotation);
var SquigglyAnnotation = function (_Annotation14) {
  _inherits(SquigglyAnnotation, _Annotation14);
  var _super15 = _createSuper(SquigglyAnnotation);
  function SquigglyAnnotation(data) {
    var _this14;
    _classCallCheck(this, SquigglyAnnotation);
    _this14 = _super15.call(this, data);
    var dict = data.annotationObject;
    _this14.data.quadPoints = dict.get("QuadPoints");
    return _this14;
  }
  return _createClass(SquigglyAnnotation);
}(Annotation);
var StrikeOutAnnotation = function (_Annotation15) {
  _inherits(StrikeOutAnnotation, _Annotation15);
  var _super16 = _createSuper(StrikeOutAnnotation);
  function StrikeOutAnnotation(data) {
    var _this15;
    _classCallCheck(this, StrikeOutAnnotation);
    _this15 = _super16.call(this, data);
    var dict = data.annotationObject;
    _this15.data.quadPoints = dict.get("QuadPoints");
    return _this15;
  }
  return _createClass(StrikeOutAnnotation);
}(Annotation);
var StampAnnotation = function (_Annotation16) {
  _inherits(StampAnnotation, _Annotation16);
  var _super17 = _createSuper(StampAnnotation);
  function StampAnnotation(data) {
    _classCallCheck(this, StampAnnotation);
    return _super17.call(this, data);
  }
  return _createClass(StampAnnotation);
}(Annotation);
var FileAttachmentAnnotation = function (_Annotation17) {
  _inherits(FileAttachmentAnnotation, _Annotation17);
  var _super18 = _createSuper(FileAttachmentAnnotation);
  function FileAttachmentAnnotation(data) {
    var _this16;
    _classCallCheck(this, FileAttachmentAnnotation);
    _this16 = _super18.call(this, data);
    var file = new _parser.FileSpec(data.annotationObject.get("FS"), data.xref);
    _this16.data.file = {
      filename: file.filename,
      content: file.content
    };
    return _this16;
  }
  return _createClass(FileAttachmentAnnotation);
}(Annotation);
var BorderStyle = function () {
  function BorderStyle(dict) {
    _classCallCheck(this, BorderStyle);
    this.width = 1;
    this.style = _primitives.Name.get("S");
    this.dashArray = [3];
    this.horizontalCornerRadius = 0;
    this.verticalCornerRadius = 0;
    var border = dict.get("Border");
    if (Array.isArray(border) && border.length >= 3) {
      this.horizontalCornerRadius = border[0];
      this.verticalCornerRadius = border[1];
      this.width = border[2];
      if (border.length === 4) {
        this.dashArray = border[3];
      }
    } else {
      var bs = dict.get("BS");
      if ((0, _primitives.isDict)(bs)) {
        var dictType = bs.get("Type");
        if (!dictType || dictType.name === "Border") {
          this.width = bs.get("W") || 1;
          this.style = bs.get("S") || _primitives.Name.get("S");
          var d = bs.get("D");
          if (Array.isArray(d)) {
            this.dashArray = d;
          }
        }
      }
    }
    this.style = this.style.name;
  }
  _createClass(BorderStyle, [{
    key: "isSolid",
    get: function get() {
      return this.style === "S";
    }
  }, {
    key: "isDashed",
    get: function get() {
      return this.style === "D";
    }
  }, {
    key: "isBeveled",
    get: function get() {
      return this.style === "B";
    }
  }, {
    key: "isInset",
    get: function get() {
      return this.style === "I";
    }
  }, {
    key: "isUnderlined",
    get: function get() {
      return this.style === "U";
    }
  }]);
  return BorderStyle;
}();
var Font = function () {
  function Font(data) {
    _classCallCheck(this, Font);
    var dict = data.dict;
    this.name = data.name;
    this.font = dict;
    this.xref = data.xref;
    this.isType3Font = false;
    this.isType1Font = false;
    this.isTrueTypeFont = false;
    this.isCIDFont = false;
    this.isSymbolicFont = false;
    this.isSerifFont = false;
    this.toUnicode = dict.has("ToUnicode") ? dict.get("ToUnicode") : null;
    this.toUnicodePromise = null;
    this.baseFont = dict.get("BaseFont").name;
    this.firstChar = dict.get("FirstChar") || 0;
    this.lastChar = dict.get("LastChar") || 255;
    var widths = dict.get("Widths");
    this.widths = Array.isArray(widths) ? widths : null;
    this.ascent = dict.get("Ascent") || 0;
    this.descent = dict.get("Descent") || 0;
    this.fontMatrix = dict.get("FontMatrix") || _util.FONT_IDENTITY_MATRIX;
    var fontDescriptor = dict.get("FontDescriptor");
    if (fontDescriptor) {
      this.fontBBox = fontDescriptor.get("FontBBox");
      var flags = fontDescriptor.get("Flags");
      this.isSymbolicFont = !!(flags & 4);
      this.isSerifFont = !!(flags & 2);
    }
  }
  _createClass(Font, [{
    key: "_getToUnicode",
    value: function _getToUnicode() {
      var _this17 = this;
      return new Promise(function (resolve) {
        if (!_this17.toUnicode || (0, _primitives.isDict)(_this17.toUnicode)) {
          resolve(_this17.toUnicode);
          return;
        }
        if (_this17.toUnicodePromise) {
          resolve(_this17.toUnicodePromise);
          return;
        }
        var capability = (0, _util.createPromiseCapability)();
        _this17.toUnicodePromise = capability.promise;
        var partialEvaluator = new PartialEvaluator({
          xref: _this17.xref,
          handler: new _parser.Handler(),
          pageIndex: -1,
          idFactory: new _parser.IDFactory()
        });
        var toUnicodeStream = _this17.toUnicode;
        var CMapFactory = __webpack_require__(16).CMapFactory;
        partialEvaluator.getOperatorList({
          stream: toUnicodeStream,
          task: null,
          resources: _primitives.Dict.empty,
          operatorList: {
            fnArray: [],
            argsArray: []
          }
        }).then(function (opList) {
          var cMap = CMapFactory.create(toUnicodeStream.dict, opList, null);
          _this17.toUnicode = cMap;
          capability.resolve(cMap);
        }).catch(function (reason) {
          (0, _util.warn)("Unable to load ToUnicode CMap: ".concat(reason));
          _this17.toUnicode = null;
          capability.resolve(null);
        });
        resolve(_this17.toUnicodePromise);
      });
    }
  }, {
    key: "exportData",
    value: function exportData() {
      var _this18 = this;
      return this._getToUnicode().then(function (toUnicode) {
        return {
          name: _this18.name,
          font: _this18.font.toString(),
          toUnicode: toUnicode ? toUnicode.export() : null,
          firstChar: _this18.firstChar,
          lastChar: _this18.lastChar,
          widths: _this18.widths,
          ascent: _this18.ascent,
          descent: _this18.descent,
          fontMatrix: _this18.fontMatrix,
          fontBBox: _this18.fontBBox,
          isSymbolicFont: _this18.isSymbolicFont,
          isSerifFont: _this18.isSerifFont
        };
      });
    }
  }], [{
    key: "clearCache",
    value: function clearCache() {
      this.cache = Object.create(null);
      this.preEvaluatedFonts = Object.create(null);
    }
  }, {
    key: "getFontDict",
    value: function getFontDict(xref, dict) {
      var fontDict = dict.get("Font");
      if ((0, _primitives.isDict)(fontDict)) {
        return fontDict;
      }
      var resources = dict.get("Resources");
      if ((0, _primitives.isDict)(resources)) {
        return resources.get("Font");
      }
      return null;
    }
  }, {
    key: "getFont",
    value: function getFont(xref, dict, defaultFont) {
      var fontDict = this.getFontDict(xref, dict);
      if (fontDict) {
        return fontDict.get(dict.get("FontName").name);
      }
      return defaultFont;
    }
  }, {
    key: "loadFont",
    value: function loadFont(xref, dict) {
      if (!this.cache) {
        this.cache = Object.create(null);
      }
      var ref = dict.objId;
      if (ref && this.cache[ref]) {
        return this.cache[ref];
      }
      var font = this.create(xref, dict);
      if (ref) {
        this.cache[ref] = font;
      }
      return font;
    }
  }, {
    key: "create",
    value: function create(xref, dict) {
      var subtype = dict.get("Subtype");
      if (subtype.name === "Type1") {
        return new Type1Font({
          xref: xref,
          dict: dict
        });
      }
      if (subtype.name === "TrueType") {
        return new TrueTypeFont({
          xref: xref,
          dict: dict
        });
      }
      (0, _util.warn)("Unimplemented font type: ".concat(subtype.name));
      return null;
    }
  }, {
    key: "preEvaluateFont",
    value: function preEvaluateFont(xref, dict) {
      var _this19 = this;
      if (!this.preEvaluatedFonts) {
        this.preEvaluatedFonts = Object.create(null);
      }
      var ref = dict.objId;
      if (ref && this.preEvaluatedFonts[ref]) {
        return this.preEvaluatedFonts[ref];
      }
      var fontPromise = this.loadFont(xref, dict);
      if (fontPromise) {
        fontPromise.then(function (font) {
          _this19.preEvaluatedFonts[ref] = font;
        });
      }
      return fontPromise;
    }
  }]);
  return Font;
}();
exports.Font = Font;
var Type1Font = function (_Font) {
  _inherits(Type1Font, _Font);
  var _super19 = _createSuper(Type1Font);
  function Type1Font(params) {
    var _this20;
    _classCallCheck(this, Type1Font);
    _this20 = _super19.call(this, params);
    _this20.isType1Font = true;
    return _this20;
  }
  return _createClass(Type1Font);
}(Font);
var TrueTypeFont = function (_Font2) {
  _inherits(TrueTypeFont, _Font2);
  var _super20 = _createSuper(TrueTypeFont);
  function TrueTypeFont(params) {
    var _this21;
    _classCallCheck(this, TrueTypeFont);
    _this21 = _super20.call(this, params);
    _this21.isTrueTypeFont = true;
    return _this21;
  }
  return _createClass(TrueTypeFont);
}(Font);
var CIDFont = function (_Font3) {
  _inherits(CIDFont, _Font3);
  var _super21 = _createSuper(CIDFont);
  function CIDFont(params) {
    var _this22;
    _classCallCheck(this, CIDFont);
    _this22 = _super21.call(this, params);
    _this22.isCIDFont = true;
    _this22.cidTransform = params.dict.get("CIDTransform");
    return _this22;
  }
  return _createClass(CIDFont);
}(Font);
var isAnnots = function isAnnots(op) {
  return op === _util.OPS.beginMarkedContent || op === _util.OPS.beginMarkedContentProps || op === _util.OPS.endMarkedContent || op === _util.OPS.beginGroup || op === _util.OPS.endGroup;
};
exports.isAnnots = isAnnots;
var isXFA = function isXFA(op) {
  return op === _util.OPS.beginGroup || op === _util.OPS.endGroup;
};
exports.isXFA = isXFA;
var PartialEvaluator = function () {
  function PartialEvaluator(_ref3) {
    var xref = _ref3.xref,
      handler = _ref3.handler,
      pageIndex = _ref3.pageIndex,
      idFactory = _ref3.idFactory,
      fontCache = _ref3.fontCache,
      builtInCMapCache = _ref3.builtInCMapCache,
      standardFontDataCache = _ref3.standardFontDataCache,
      pdfManager = _ref3.pdfManager;
    _classCallCheck(this, PartialEvaluator);
    this.xref = xref;
    this.handler = handler;
    this.pageIndex = pageIndex;
    this.idFactory = idFactory;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.standardFontDataCache = standardFontDataCache;
    this.pdfManager = pdfManager;
    this.parsingState = new _parser.ParserState();
  }
  _createClass(PartialEvaluator, [{
    key: "getOperatorList",
    value: function getOperatorList(_ref4) {
      var _this23 = this;
      var stream = _ref4.stream,
        task = _ref4.task,
        resources = _ref4.resources,
        operatorList = _ref4.operatorList;
      var self = this;
      var xref = this.xref;
      var handler = this.handler;
      var parsingState = this.parsingState;
      var imageCache = Object.create(null);
      var promise = new Promise(function (resolve, reject) {
        var parser = new _parser.Parser({
          lexer: new _parser.Lexer(stream),
          xref: xref
        });
        function cont() {
          var obj = parser.getObj();
          if ((0, _primitives.isEOF)(obj)) {
            resolve({
              operatorList: operatorList,
              imageCache: imageCache
            });
          } else {
            if ((0, _primitives.isCmd)(obj)) {
              var cmd = obj.cmd;
              var args = parser.getObj();
              self.executeCommand(cmd, args, {
                stream: stream,
                resources: resources,
                operatorList: operatorList
              }).then(function (result) {
                if (result) {
                  handler.send(result.fn, result.args);
                }
                cont();
              }).catch(function (reason) {
                reject(reason);
              });
            } else {
              cont();
            }
          }
        }
        cont();
      });
      return promise;
    }
  }, {
    key: "getLinearized",
    value: function getLinearized() {
      return Promise.resolve(this.xref.trailer.get("Linearized"));
    }
  }, {
    key: "getPermissions",
    value: function getPermissions() {
      return this.xref.getPermissions();
    }
  }, {
    key: "getDestinations",
    value: function getDestinations() {
      var _this24 = this;
      return new Promise(function (resolve) {
        var destinations = Object.create(null);
        var xref = _this24.xref;
        var trailer = xref.trailer;
        var names = trailer.get("Names");
        if ((0, _primitives.isDict)(names)) {
          var dests = names.get("Dests");
          if ((0, _primitives.isDict)(dests)) {
            var namesArray = dests.get("Names");
            if (Array.isArray(namesArray)) {
              for (var i = 0, ii = namesArray.length; i < ii; i += 2) {
                destinations[namesArray[i]] = namesArray[i + 1];
              }
            }
          }
        }
        var catalog = trailer.get("Root");
        if ((0, _primitives.isDict)(catalog)) {
          var _dests = catalog.get("Dests");
          if ((0, _primitives.isDict)(_dests)) {
            _dests.forEach(function (key, value) {
              if (value) {
                destinations[key] = value;
              }
            });
          }
        }
        resolve(destinations);
      });
    }
  }, {
    key: "getAttachments",
    value: function getAttachments() {
      var _this25 = this;
      return new Promise(function (resolve) {
        var attachments = Object.create(null);
        var xref = _this25.xref;
        var trailer = xref.trailer;
        var names = trailer.get("Names");
        if ((0, _primitives.isDict)(names)) {
          var embeddedFiles = names.get("EmbeddedFiles");
          if ((0, _primitives.isDict)(embeddedFiles)) {
            var namesArray = embeddedFiles.get("Names");
            if (Array.isArray(namesArray)) {
              for (var i = 0, ii = namesArray.length; i < ii; i += 2) {
                attachments[namesArray[i]] = new _parser.FileSpec(namesArray[i + 1], xref);
              }
            }
          }
        }
        resolve(attachments);
      });
    }
  }, {
    key: "getJavaScript",
    value: function getJavaScript() {
      var _this26 = this;
      return new Promise(function (resolve, reject) {
        var trailer = _this26.xref.trailer;
        var names = trailer.get("Names");
        if (!(0, _primitives.isDict)(names)) {
          resolve([]);
          return;
        }
        var javaScript = names.get("JavaScript");
        if (!(0, _primitives.isDict)(javaScript)) {
          resolve([]);
          return;
        }
        var namesArray = javaScript.get("Names");
        if (!Array.isArray(namesArray)) {
          resolve([]);
          return;
        }
        var scripts = [];
        for (var i = 0, ii = namesArray.length; i < ii; i += 2) {
          var js = _this26.xref.fetch(namesArray[i + 1]);
          var s = js.get("S");
          if (s.name !== "JavaScript") {
            continue;
          }
          var script = js.get("JS");
          if ((0, _primitives.isStream)(script)) {
            scripts.push(script.getString());
          } else if (typeof script === "string") {
            scripts.push(script);
          }
        }
        resolve(scripts);
      });
    }
  }, {
    key: "getOutline",
    value: function getOutline() {
      var _this27 = this;
      return new Promise(function (resolve, reject) {
        var trailer = _this27.xref.trailer;
        var root = trailer.get("Root");
        var outline = root.get("Outlines");
        if (!(0, _primitives.isDict)(outline)) {
          resolve(null);
          return;
        }
        var outlineDict = outline;
        var items = [];
        var first = outlineDict.get("First");
        if (!(0, _primitives.isRef)(first)) {
          resolve(items);
          return;
        }
        var queue = [{
          parent: items,
          ref: first
        }];
        var processed = new _primitives.RefSet();
        processed.put(first);
        while (queue.length > 0) {
          var i = queue.shift();
          var obj = _this27.xref.fetch(i.ref);
          if (!obj) {
            continue;
          }
          var dest = obj.get("Dest");
          if ((0, _primitives.isName)(dest)) {
            dest = dest.name;
          }
          var a = obj.get("A");
          var action;
          if ((0, _primitives.isDict)(a)) {
            action = {
              type: a.get("S").name
            };
            if (action.type === "GoTo") {
              action.dest = a.get("D");
            } else {
              action = null;
            }
          }
          var item = {
            title: obj.get("Title"),
            bold: obj.has("F") && (obj.get("F") & 2) !== 0,
            italic: obj.has("F") && (obj.get("F") & 1) !== 0,
            color: obj.get("C") || [0, 0, 0],
            dest: dest,
            action: action,
            url: null,
            unsafeUrl: null,
            newWindow: false,
            count: obj.get("Count"),
            items: []
          };
          if ((0, _primitives.isDict)(a) && a.get("S").name === "URI") {
            var unsafeUrl = a.get("URI");
            if (typeof unsafeUrl === "string") {
              item.unsafeUrl = unsafeUrl;
              if (!(0, _util.validateUrl)(unsafeUrl)) {
                (0, _util.warn)("Invalid outline item URL: ".concat(unsafeUrl));
                item.unsafeUrl = null;
              }
            }
          }
          i.parent.push(item);
          var next = obj.get("Next");
          if ((0, _primitives.isRef)(next)) {
            if (processed.has(next)) {
              reject(new Error("Outline has a cycle"));
              return;
            }
            processed.put(next);
            queue.push({
              parent: i.parent,
              ref: next
            });
          }
          var _first = obj.get("First");
          if ((0, _primitives.isRef)(_first)) {
            if (processed.has(_first)) {
              reject(new Error("Outline has a cycle"));
              return;
            }
            processed.put(_first);
            queue.push({
              parent: item.items,
              ref: _first
            });
          }
        }
        resolve(items);
      });
    }
  }, {
    key: "getOptionalContentConfig",
    value: function getOptionalContentConfig() {
      var _this28 = this;
      return new Promise(function (resolve) {
        var trailer = _this28.xref.trailer;
        var root = trailer.get("Root");
        var ocs = root.get("OCProperties");
        if (!(0, _primitives.isDict)(ocs)) {
          resolve(null);
          return;
        }
        resolve(new OptionalContentConfig(ocs, _this28.xref));
      });
    }
  }, {
    key: "createDefaultAppearance",
    value: function createDefaultAppearance(dict) {
      var da = dict.get("DA");
      if (typeof da !== "string") {
        return Promise.resolve();
      }
      var tokens = new _parser.Lexer(new _stream.StringStream(da)).getObj();
      var R = dict.get("DR");
      var fontName,
        fontSize = 0,
        fontColor = [0, 0, 0];
      if (tokens.length >= 2 && (0, _primitives.isName)(tokens[0])) {
        fontName = tokens[0].name;
        var font = R.get("Font");
        if (font) {
          var fontDict = font.get(fontName);
          if (fontDict && fontDict.get("Subtype").name === "Type3") {
            return Promise.resolve();
          }
        }
        fontSize = tokens[1];
      }
      var _loop = function _loop(i, ii) {
        if ((0, _primitives.isCmd)(tokens[i], "g")) {
          fontColor = [tokens[i - 1]];
        } else if ((0, _primitives.isCmd)(tokens[i], "rg")) {
          fontColor = [tokens[i - 3], tokens[i - 2], tokens[i - 1]];
        } else if ((0, _primitives.isCmd)(tokens[i], "k")) {
          fontColor = [tokens[i - 4], tokens[i - 3], tokens[i - 2], tokens[i - 1]];
        } else {
          return "continue";
        }
        var promise = new Promise(function (resolveColor, rejectColor) {
          var cs = R.get("ColorSpace");
          if (cs) {
            _colorspace.ColorSpace.parseAsync({
              cs: cs.get("DefaultGray"),
              xref: null,
              resources: null,
              pdfManager: null
            }).then(function (gray) {
              resolveColor(gray.getRgb(fontColor, 0));
            });
          } else {
            resolveColor(fontColor);
          }
        });
        promise.then(function (color) {
          fontColor = color;
        });
        return "break";
      };
      for (var i = 0, ii = tokens.length; i < ii; i++) {
        var _ret = _loop(i, ii);
        if (_ret === "continue") continue;
        if (_ret === "break") break;
      }
      var appearance = "".concat(fontName, " ").concat(fontSize, "px").concat(fontColor.join(","), ")");
      return Promise.resolve(appearance);
    }
  }, {
    key: "getMetadata",
    value: function getMetadata() {
      var _this29 = this;
      return new Promise(function (resolve) {
        var trailer = _this29.xref.trailer;
        var info = trailer.get("Info") || _primitives.Dict.empty;
        var metadata = info.get("Metadata");
        if (!(0, _primitives.isStream)(metadata)) {
          resolve({
            info: info.toJSObject(),
            metadata: null
          });
          return;
        }
        var charset = "utf-8";
        var type = metadata.dict.get("Type");
        if ((0, _primitives.isName)(type) && type.name === "XML") {
          var subtype = metadata.dict.get("Subtype");
          if ((0, _primitives.isName)(subtype) && subtype.name !== "XML") {
            (0, _util.warn)("Unsupported metadata subtype: " + subtype.name);
          }
        }
        var length = metadata.dict.get("Length");
        var data = new Uint8Array(length);
        metadata.stream.readBytes(data);
        var str = (0, _util.bytesToString)(data);
        var i = 0,
          iLength = str.length;
        while (i < iLength && str[i] !== "<") {
          i++;
        }
        str = str.substr(i);
        var m = /charset\s*=\s*([a-zA-Z0-9_ -]+)/i.exec(str);
        if (m) {
          charset = m[1].trim().toLowerCase();
        }
        var decodedString;
        if (charset === "utf-8") {
          decodedString = str;
        } else if (typeof TextDecoder !== "undefined") {
          try {
            decodedString = new TextDecoder(charset).decode(data);
          } catch (e) {
            if (e.name === "RangeError") {
              (0, _util.warn)("Invalid charset for metadata: ".concat(charset));
              decodedString = (0, _util.bytesToString)(data);
            } else {
              throw e;
            }
          }
        } else {
          decodedString = (0, _util.bytesToString)(data);
        }
        resolve({
          info: info.toJSObject(),
          metadata: decodedString
        });
      });
    }
  }, {
    key: "parse",
    value: function parse() {
      var _this30 = this;
      var recoveryMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.xref.parse(recoveryMode);
      var trailer = this.xref.trailer;
      var root = trailer.get("Root");
      if (!(0, _primitives.isDict)(root)) {
        throw new _util.InvalidPDFException("Invalid root dictionary.");
      }
      var version = root.get("Version");
      if ((0, _primitives.isName)(version)) {
        this.pdfManager.pdfDocument.pdfInfo.version = version.name;
      }
      this.pdfManager.pdfDocument.pdfInfo.catalog = new Catalog(this.pdfManager, this.xref, root);
      return new Promise(function (resolve) {
        var pageProms = [];
        for (var i = 0, ii = _this30.pdfManager.pdfDocument.pdfInfo.catalog.numPages; i < ii; i++) {
          pageProms.push(_this30.pdfManager.pdfDocument.pdfInfo.catalog.getPage(i));
        }
        Promise.all(pageProms).then(function (pages) {
          _this30.pdfManager.pdfDocument.pdfInfo.catalog.fontCache = _this30.fontCache;
          resolve();
        });
      });
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(cmd, args, state) {
      switch (cmd) {
        case "w":
          return Promise.resolve({
            fn: _util.OPS.setLineWidth,
            args: args
          });
        case "J":
          return Promise.resolve({
            fn: _util.OPS.setLineCap,
            args: args
          });
        case "j":
          return Promise.resolve({
            fn: _util.OPS.setLineJoin,
            args: args
          });
        case "M":
          return Promise.resolve({
            fn: _util.OPS.setMiterLimit,
            args: args
          });
        case "d":
          return Promise.resolve({
            fn: _util.OPS.setDash,
            args: args
          });
        case "ri":
          return Promise.resolve({
            fn: _util.OPS.setRenderingIntent,
            args: args
          });
        case "i":
          return Promise.resolve({
            fn: _util.OPS.setFlatness,
            args: args
          });
        case "gs":
          return this.handleSetGState(args, state);
        case "q":
          return Promise.resolve({
            fn: _util.OPS.save
          });
        case "Q":
          return Promise.resolve({
            fn: _util.OPS.restore
          });
        case "cm":
          return Promise.resolve({
            fn: _util.OPS.transform,
            args: args
          });
        case "m":
          return Promise.resolve({
            fn: _util.OPS.moveTo,
            args: args
          });
        case "l":
          return Promise.resolve({
            fn: _util.OPS.lineTo,
            args: args
          });
        case "c":
          return Promise.resolve({
            fn: _util.OPS.curveTo,
            args: args
          });
        case "v":
          return Promise.resolve({
            fn: _util.OPS.curveTo2,
            args: args
          });
        case "y":
          return Promise.resolve({
            fn: _util.OPS.curveTo3,
            args: args
          });
        case "h":
          return Promise.resolve({
            fn: _util.OPS.closePath
          });
        case "re":
          return Promise.resolve({
            fn: _util.OPS.rectangle,
            args: args
          });
        case "S":
          return Promise.resolve({
            fn: _util.OPS.stroke
          });
        case "s":
          return Promise.resolve({
            fn: _util.OPS.closeStroke
          });
        case "f":
        case "F":
          return Promise.resolve({
            fn: _util.OPS.fill
          });
        case "f*":
          return Promise.resolve({
            fn: _util.OPS.eoFill
          });
        case "B":
          return Promise.resolve({
            fn: _util.OPS.fillStroke
          });
        case "B*":
          return Promise.resolve({
            fn: _util.OPS.eoFillStroke
          });
        case "b":
          return Promise.resolve({
            fn: _util.OPS.closeFillStroke
          });
        case "b*":
          return Promise.resolve({
            fn: _util.OPS.closeEOFillStroke
          });
        case "n":
          return Promise.resolve({
            fn: _util.OPS.endPath
          });
        case "W":
          return Promise.resolve({
            fn: _util.OPS.clip
          });
        case "W*":
          return Promise.resolve({
            fn: _util.OPS.eoClip
          });
        case "BT":
          return Promise.resolve({
            fn: _util.OPS.beginText
          });
        case "ET":
          return Promise.resolve({
            fn: _util.OPS.endText
          });
        case "Tc":
          return Promise.resolve({
            fn: _util.OPS.setCharSpacing,
            args: args
          });
        case "Tw":
          return Promise.resolve({
            fn: _util.OPS.setWordSpacing,
            args: args
          });
        case "Tz":
          return Promise.resolve({
            fn: _util.OPS.setHScale,
            args: args
          });
        case "TL":
          return Promise.resolve({
            fn: _util.OPS.setLeading,
            args: args
          });
        case "Tf":
          return this.handleSetFont(args, state);
        case "Tr":
          return Promise.resolve({
            fn: _util.OPS.setTextRenderMode,
            args: args
          });
        case "Ts":
          return Promise.resolve({
            fn: _util.OPS.setTextRise,
            args: args
          });
        case "Td":
          return Promise.resolve({
            fn: _util.OPS.moveText,
            args: args
          });
        case "TD":
          return Promise.resolve({
            fn: _util.OPS.setLeadingMoveText,
            args: args
          });
        case "Tm":
          return Promise.resolve({
            fn: _util.OPS.setTextMatrix,
            args: args
          });
        case "T*":
          return Promise.resolve({
            fn: _util.OPS.nextLIne
          });
        case "Tj":
          return Promise.resolve({
            fn: _util.OPS.showText,
            args: args
          });
        case "TJ":
          return Promise.resolve({
            fn: _util.OPS.showSpacedText,
            args: args
          });
        case "'":
          return Promise.resolve({
            fn: _util.OPS.nextLineShowText,
            args: args
          });
        case '"':
          return Promise.resolve({
            fn: _util.OPS.nextLineShowSpacedText,
            args: args
          });
        case "CS":
          return Promise.resolve({
            fn: _util.OPS.setStrokeColorSpace,
            args: args
          });
        case "cs":
          return Promise.resolve({
            fn: _util.OPS.setFillColorSpace,
            args: args
          });
        case "SCN":
          return Promise.resolve({
            fn: _util.OPS.setStrokeColorN,
            args: args
          });
        case "scn":
          return Promise.resolve({
            fn: _util.OPS.setFillColorN,
            args: args
          });
        case "g":
          return Promise.resolve({
            fn: _util.OPS.setStrokeGray,
            args: args
          });
        case "G":
          return Promise.resolve({
            fn: _util.OPS.setFillGray,
            args: args
          });
        case "rg":
          return Promise.resolve({
            fn: _util.OPS.setStrokeRGBColor,
            args: args
          });
        case "RG":
          return Promise.resolve({
            fn: _util.OPS.setFillRGBColor,
            args: args
          });
        case "k":
          return Promise.resolve({
            fn: _util.OPS.setStrokeCMYKColor,
            args: args
          });
        case "K":
          return Promise.resolve({
            fn: _util.OPS.setFillCMYKColor,
            args: args
          });
        case "sh":
          return Promise.resolve({
            fn: _util.OPS.shadingFill,
            args: args
          });
        case "BI":
          return Promise.resolve({
            fn: _util.OPS.beginInlineImage,
            args: args
          });
        case "ID":
          return Promise.resolve({
            fn: _util.OPS.beginImageData,
            args: args
          });
        case "EI":
          return Promise.resolve({
            fn: _util.OPS.endInlineImage,
            args: args
          });
        case "Do":
          return this.handleDo(args, state);
        case "MP":
          return Promise.resolve({
            fn: _util.OPS.markPoint,
            args: args
          });
        case "DP":
          return Promise.resolve({
            fn: _util.OPS.markPointProps,
            args: args
          });
        case "BMC":
          return Promise.resolve({
            fn: _util.OPS.beginMarkedContent,
            args: args
          });
        case "BDC":
          return Promise.resolve({
            fn: _util.OPS.beginMarkedContentProps,
            args: args
          });
        case "EMC":
          return Promise.resolve({
            fn: _util.OPS.endMarkedContent,
            args: args
          });
        case "BX":
          return Promise.resolve({
            fn: _util.OPS.beginCompat
          });
        case "EX":
          return Promise.resolve({
            fn: _util.OPS.endCompat
          });
        default:
          return Promise.resolve(null);
      }
    }
  }, {
    key: "handleSetFont",
    value: function handleSetFont(args, state) {
      var _this31 = this;
      var fontName = args[0].name;
      var font = state.resources.get("Font").get(fontName);
      if (!font) {
        throw new Error("Could not find font");
      }
      return this.loadFont(fontName, font, state.resources).then(function (loadedFont) {
        state.font = loadedFont;
        state.fontSize = args[1];
        return {
          fn: _util.OPS.setFont,
          args: [loadedFont.name, state.fontSize]
        };
      });
    }
  }, {
    key: "handleSetGState",
    value: function handleSetGState(args, state) {
      var _this32 = this;
      var gStateName = args[0].name;
      var gState = state.resources.get("ExtGState").get(gStateName);
      if (!gState) {
        return Promise.resolve(null);
      }
      return this.loadFont(gState.get("Font")[0].name, gState.get("Font"), state.resources).then(function (loadedFont) {
        state.font = loadedFont;
        state.fontSize = gState.get("Font")[1];
        return {
          fn: _util.OPS.setGState,
          args: [gState.toJSObject()]
        };
      });
    }
  }, {
    key: "handleDo",
    value: function handleDo(args, state) {
      var xobjectName = args[0].name;
      var xobject = state.resources.get("XObject").get(xobjectName);
      if (!xobject) {
        return Promise.resolve(null);
      }
      if (xobject.dict.get("Subtype").name === "Form") {
        return Promise.resolve({
          fn: _util.OPS.paintFormXObjectBegin,
          args: args
        });
      }
      if (xobject.dict.get("Subtype").name === "Image") {
        return Promise.resolve({
          fn: _util.OPS.paintImageXObject,
          args: args
        });
      }
      return Promise.resolve(null);
    }
  }, {
    key: "loadFont",
    value: function loadFont(fontName, font, resources) {
      var _this33 = this;
      var fontRef;
      if (font) {
        fontRef = (0, _primitives.isRef)(font) ? font : font.objId;
      }
      if (this.fontCache.has(fontRef)) {
        return this.fontCache.get(fontRef);
      }
      if (!font) {
        throw new Error("Could not find font");
      }
      var fontPromise = new Promise(function (resolve, reject) {
        var fontData = {
          name: fontName,
          dict: font,
          xref: _this33.xref
        };
        var newFont = Font.create(fontData);
        if (newFont) {
          if (newFont.isType3Font) {} else if (newFont.isCIDFont) {
            _this33.loadCIDFont(newFont, resources).then(function () {
              resolve(newFont);
            });
          } else {
            _this33.loadStandardFont(newFont).then(function () {
              resolve(newFont);
            });
          }
        }
      });
      this.fontCache.put(fontRef, fontPromise);
      return fontPromise;
    }
  }, {
    key: "loadStandardFont",
    value: function loadStandardFont(font) {
      var _this34 = this;
      var baseFontName = font.baseFont.replace(/ /g, "");
      if (!this.standardFontDataCache.has(baseFontName)) {
        var promise = new Promise(function (resolve, reject) {
          _this34.pdfManager.loadStandardFont(baseFontName).then(function (data) {
            _this34.standardFontDataCache.set(baseFontName, data);
            resolve(data);
          }).catch(function (reason) {
            (0, _util.warn)("Could not load standard font: ".concat(reason));
            resolve(null);
          });
        });
        this.standardFontDataCache.set(baseFontName, promise);
        return promise;
      }
      return this.standardFontDataCache.get(baseFontName);
    }
  }, {
    key: "loadCIDFont",
    value: function loadCIDFont(font, resources) {
      var _this35 = this;
      var cidSystemInfo = font.dict.get("CIDSystemInfo");
      var registry = cidSystemInfo.get("Registry");
      var ordering = cidSystemInfo.get("Ordering");
      var supplement = cidSystemInfo.get("Supplement");
      var promise = new Promise(function (resolve, reject) {
        _this35.pdfManager.loadCMap(registry, ordering, supplement, font.toUnicode.name).then(function (data) {
          font.cMap = data.cMap;
          font.vertical = data.vertical;
          resolve();
        });
      });
      return promise;
    }
  }]);
  return PartialEvaluator;
}();
var TextContent = function () {
  function TextContent() {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref6$items = _ref6.items,
      items = _ref6$items === void 0 ? [] : _ref6$items,
      _ref6$styles = _ref6.styles,
      styles = _ref6$styles === void 0 ? Object.create(null) : _ref6$styles;
    _classCallCheck(this, TextContent);
    this.items = items;
    this.styles = styles;
  }
  _createClass(TextContent, [{
    key: "getItems",
    value: function getItems() {
      return this.items;
    }
  }, {
    key: "getStyles",
    value: function getStyles() {
      return this.styles;
    }
  }]);
  return TextContent;
}();
exports.TextContent = TextContent;
function bidi(items, rtl) {
  if (!rtl) {
    return;
  }
  var
  str = items.map(function (item) {
    return item.str;
  }).join("");
  var bidiResult = (0, _bidi.bidi)(str, -1, false);
  var dir = bidiResult.dir;
  var levels = bidiResult.levels;
  var i = 0;
  for (var _i = 0, _ii = items.length; _i < _ii; _i++) {
    var item = items[_i];
    var start = i;
    var end = i + item.str.length - 1;
    while (start < end && levels[start] !== levels[end]) {
      start++;
      end--;
    }
    if (levels[start] > 0) {
      item.dir = "rtl";
    }
    i += item.str.length;
  }
}
function getTextContent(opList, normalizeWhitespace, combineTextItems, includeImage) {
  var bidiText = new _bidi.BidiText();
  var textContent = {
    items: [],
    styles: {}
  };
  var Tfs = new _parser.ParserState();
  var Tm = [1, 0, 0, 1, 0, 0];
  var Tl = 0;
  var Tfs_ = Tfs;
  var Tm_ = Tm;
  var Tl_ = Tl;
  var fontName;
  var textMatrix, textLineMatrix, font, fontSize, fontDirection, fontWeight, fontStyle;
  var textRise = 0;
  var x, y;
  var spaceWidth = 0;
  var currentTextTransform;
  var currentSpaceConversion;
  var fnArray = opList.fnArray;
  var fnCache = Object.create(null);
  var argsArray = opList.argsArray;
  var i, ii;
  for (i = 0, ii = fnArray.length; i < ii; i++) {
    var fn = fnArray[i];
    var args = argsArray[i];
    if (fn === _util.OPS.setFont) {
      Tfs_.font = args[0];
      Tfs_.fontSize = args[1];
    } else if (fn === _util.OPS.setTextMatrix) {
      Tm_ = args;
    } else if (fn === _util.OPS.setLeading) {
      Tl_ = args[0];
    } else if (fn === _util.OPS.beginText) {
      Tfs_ = Tfs;
      Tm_ = Tm;
      Tl_ = Tl;
    } else if (fn === _util.OPS.showText) {
      var str = args[0];
      for (var j = 0, jj = str.length; j < jj; j++) {
        var item = {
          str: str[j],
          dir: "ltr",
          width: 0,
          height: 0,
          transform: [Tfs_.fontSize * Tm_[0], Tfs_.fontSize * Tm_[1], -Tfs_.fontSize * Tm_[2], -Tfs_.fontSize * Tm_[3], Tm_[4], Tm_[5]],
          fontName: Tfs_.font.name
        };
        textContent.items.push(item);
      }
    } else if (fn === _util.OPS.showSpacedText) {
      var arr = args[0];
      for (var _j = 0, _jj = arr.length; _j < _jj; _j++) {
        var _item = {
          str: arr[_j],
          dir: "ltr",
          width: 0,
          height: 0,
          transform: [Tfs_.fontSize * Tm_[0], Tfs_.fontSize * Tm_[1], -Tfs_.fontSize * Tm_[2], -Tfs_.fontSize * Tm_[3], Tm_[4], Tm_[5]],
          fontName: Tfs_.font.name
        };
        textContent.items.push(_item);
      }
    }
  }
  return textContent;
}
var OptionalContentConfig = function () {
  function OptionalContentConfig(config, xref) {
    var _this36 = this;
    _classCallCheck(this, OptionalContentConfig);
    this.name = config.get("Name");
    this.creator = config.get("Creator");
    this.baseState = config.get("BaseState").name;
    this.groups = [];
    var ocgs = config.get("OCGs");
    if (Array.isArray(ocgs)) {
      ocgs.forEach(function (ocg) {
        if ((0, _primitives.isRef)(ocg)) {
          var group = new OptionalContentGroup(ocg, xref);
          _this36.groups.push(group);
        }
      });
    }
  }
  _createClass(OptionalContentConfig, [{
    key: "getGroups",
    value: function getGroups() {
      return this.groups;
    }
  }, {
    key: "getGroup",
    value: function getGroup(id) {
      var _iterator2 = _createForOfIteratorHelper(this.groups),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var group = _step2.value;
          if (group.id === id) {
            return group;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return null;
    }
  }]);
  return OptionalContentConfig;
}();
exports.OptionalContentConfig = OptionalContentConfig;
var OptionalContentGroup = function () {
  function OptionalContentGroup(ref, xref) {
    _classCallCheck(this, OptionalContentGroup);
    var dict = xref.fetch(ref);
    this.id = ref.toString();
    this.name = dict.get("Name");
    this.intent = dict.get("Intent");
    this.usage = dict.get("Usage");
  }
  _createClass(OptionalContentGroup, [{
    key: "isViewable",
    value: function isViewable(config) {
      var on = config.baseState === "ON";
      var off = config.baseState === "OFF";
      if (on || off) {
        var _iterator3 = _createForOfIteratorHelper(config.groups),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var group = _step3.value;
            if (group.id === this.id) {
              return on;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      return false;
    }
  }]);
  return OptionalContentGroup;
}();
exports.OptionalContentGroup = OptionalContentGroup;
var PromiseQueue = function () {
  function PromiseQueue() {
    _classCallCheck(this, PromiseQueue);
    this.queue = [];
    this.busy = false;
  }
  _createClass(PromiseQueue, [{
    key: "push",
    value: function push(fn) {
      var _this37 = this;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return new Promise(function (resolve, reject) {
        _this37.queue.push({
          fn: fn,
          args: args,
          resolve: resolve,
          reject: reject
        });
        if (!_this37.busy) {
          _this37._next();
        }
      });
    }
  }, {
    key: "_next",
    value: function _next() {
      var _this38 = this;
      if (this.queue.length === 0) {
        this.busy = false;
        return;
      }
      this.busy = true;
      var task = this.queue.shift();
      Promise.resolve().then(function () {
        return task.fn.apply(null, task.args);
      }).then(function (result) {
        task.resolve(result);
        _this38._next();
      }).catch(function (reason) {
        task.reject(reason);
        _this38._next();
      });
    }
  }]);
  return PromiseQueue;
}();
exports.PromiseQueue = PromiseQueue;
var StructTreeBuilder = function () {
  function StructTreeBuilder(tree) {
    _classCallCheck(this, StructTreeBuilder);
    this.tree = tree;
  }
  _createClass(StructTreeBuilder, [{
    key: "getTree",
    value: function getTree(page) {
      var _this39 = this;
      var pageNum = page.pageIndex + 1;
      var obj = this.tree.get("Nums").get(pageNum);
      if (!obj) {
        return null;
      }
      var structTree = {
        children: []
      };
      var parent = structTree.children;
      var queue = [obj];
      var processed = new _primitives.RefSet();
      while (queue.length > 0) {
        var element = queue.shift();
        if ((0, _primitives.isRef)(element)) {
          if (processed.has(element)) {
            continue;
          }
          processed.put(element);
          element = page.xref.fetch(element);
        }
        if (Array.isArray(element)) {
          queue.push.apply(queue, element);
          continue;
        }
        if (!(0, _primitives.isDict)(element)) {
          continue;
        }
        var type = element.get("Type").name;
        if (type !== "StructElem") {
          continue;
        }
        var s = element.get("S");
        var p = element.get("P");
        if ((0, _primitives.isRef)(p)) {
          var _parent2 = {
            children: []
          };
          var _iterator4 = _createForOfIteratorHelper(this.tree.get("RoleMap").entries()),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _step4$value = _step4.value,
                key = _step4$value[0],
                value = _step4$value[1];
              if (value === s) {
                s = key;
                break;
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          _parent2.type = s;
          parent.push(_parent2);
          parent = _parent2.children;
        }
        var k = element.get("K");
        if (k) {
          queue.unshift(k);
        } else {
          var id = element.get("Pg");
          parent.push({
            type: "content",
            id: id
          });
        }
      }
      return structTree;
    }
  }]);
  return StructTreeBuilder;
}();
exports.StructTreeBuilder = StructTreeBuilder;
var OperatorList = function () {
  function OperatorList(intent, isAnnots, isXFA, data) {
    _classCallCheck(this, OperatorList);
    this.intent = intent;
    this.isAnnots = isAnnots;
    this.isXFA = isXFA;
    this.xref = data.xref;
    this.pageDict = data.pageDict;
    this.annotations = data.annotations;
    this.fontCache = data.fontCache;
    this.builtInCMapCache = data.builtInCMapCache;
    this.pdfManager = data.pdfManager;
  }
  _createClass(OperatorList, [{
    key: "getOperatorList",
    value: function getOperatorList(pageDict, xref) {
      var _this40 = this;
      var partialEvaluator = new PartialEvaluator({
        xref: xref,
        handler: this,
        pageIndex: pageDict.pageIndex,
        idFactory: this.idFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        pdfManager: this.pdfManager
      });
      var contents = pageDict.get("Contents");
      if ((0, _primitives.isStream)(contents)) {
        contents = [contents];
      }
      var streams = [];
      for (var i = 0, ii = contents.length; i < ii; i++) {
        var stream = xref.fetch(contents[i]);
        if (!isEmptyStream(stream)) {
          streams.push(stream);
        }
      }
      if (streams.length === 0) {
        return Promise.resolve({
          fnArray: new Uint8Array(),
          argsArray: []
        });
      }
      var self = this;
      var operatorList = {
        fnArray: new Uint8Array(),
        argsArray: [],
        lastChunk: false,
        addOp: function addOp(fn, args) {
          this.fnArray = new Uint8Array([].concat(_toConsumableArray(this.fnArray), [fn]));
          this.argsArray.push(args);
        }
      };
      var resources = pageDict.get("Resources") || _primitives.Dict.empty;
      var promise = streams[0].getOperatorList({
        handler: self,
        task: null,
        intent: this.intent,
        resources: resources,
        operatorList: operatorList
      }).then(function (data) {
        if (self.isAnnots) {
          return self.getAnnotationsOperatorList(data.operatorList);
        }
        return data.operatorList;
      }).then(function (data) {
        if (self.isXFA) {
          return self.getXFAOperatorList(data);
        }
        return data;
      });
      return promise.then(function (opList) {
        var _opList$fnArray;
        return {
          fnArray: (_opList$fnArray = opList.fnArray) !== null && _opList$fnArray !== void 0 ? _opList$fnArray : new Uint8Array(),
          argsArray: opList.argsArray
        };
      });
    }
  }, {
    key: "getAnnotationsOperatorList",
    value: function getAnnotationsOperatorList(opList) {
      var _this41 = this;
      var annotations = this.annotations;
      var _iterator5 = _createForOfIteratorHelper(annotations),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var annotation = _step5.value;
          var opListPromise = annotation.getOperatorList(this);
          opListPromise.then(function (data) {
            opList.fnArray = new Uint8Array([].concat(_toConsumableArray(opList.fnArray), _toConsumableArray(data.fnArray)));
            opList.argsArray.push.apply(opList.argsArray, data.argsArray);
          });
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return opList;
    }
  }, {
    key: "getXFAOperatorList",
    value: function getXFAOperatorList(opList) {
      var _this42 = this;
      var xfa = this.pageDict.get("XFA");
      if (!xfa) {
        return opList;
      }
      var xfaStream = xfa.get("XFA");
      if (!xfaStream) {
        return opList;
      }
      var xfaData = xfaStream.getBytes();
      var xfaXml = new _util.XMLParser().parse(new _stream.StringStream(xfaData));
      var xfaFactory = new _xfa_object.XfaFactory({
        pdfManager: this.pdfManager,
        xref: this.xref,
        xfa: xfaXml,
        fontCache: this.fontCache
      });
      var xfaObject = xfaFactory.createXfaObject();
      var xfaPage = xfaObject.getPage(this.pageDict.pageIndex);
      if (!xfaPage) {
        return opList;
      }
      var xfaOperatorList = {
        fnArray: new Uint8Array(),
        argsArray: [],
        addOp: function addOp(fn, args) {
          this.fnArray = new Uint8Array([].concat(_toConsumableArray(this.fnArray), [fn]));
          this.argsArray.push(args);
        }
      };
      xfaPage.getOperatorList(xfaOperatorList, this.intent);
      opList.fnArray = new Uint8Array([].concat(_toConsumableArray(opList.fnArray), _toConsumableArray(xfaOperatorList.fnArray)));
      opList.argsArray.push.apply(opList.argsArray, xfaOperatorList.argsArray);
      return opList;
    }
  }, {
    key: "send",
    value: function send(op, args) {
      var _this43 = this;
      var opList = this.current;
      if (this.isAnnots && (op === _util.OPS.beginMarkedContent || op === _util.OPS.beginMarkedContentProps)) {
        var tag = args[0];
        if (tag.name === "IRT") {
          var dict = args[1];
          if ((0, _primitives.isDict)(dict)) {
            var mcr = dict.get("MCR");
            var pg = dict.get("PG");
            if (mcr && pg) {
              var annotation = this.annotations.find(function (annot) {
                return annot.ref.num === pg.num && annot.ref.gen === pg.gen;
              });
              if (annotation) {
                var appearance = annotation.getAppearance(mcr);
                if (appearance) {
                  var opListPromise = appearance.getOperatorList({
                    handler: this,
                    task: null,
                    intent: this.intent,
                    resources: this.pageDict.get("Resources"),
                    operatorList: opList
                  });
                  opListPromise.then(function (data) {
                    opList.fnArray = new Uint8Array([].concat(_toConsumableArray(opList.fnArray), _toConsumableArray(data.fnArray)));
                    opList.argsArray.push.apply(opList.argsArray, data.argsArray);
                  });
                }
              }
            }
          }
        }
      }
      opList.addOp(op, args);
    }
  }, {
    key: "get",
    value: function get(name) {
      return this.pdfManager.ensure(this.pageDict, "get", [name]);
    }
  }, {
    key: "has",
    value: function has(name) {
      return this.pageDict.has(name);
    }
  }, {
    key: "idFactory",
    get: function get() {
      if (!this._idFactory) {
        this._idFactory = new _parser.IDFactory(this.pageDict.pageIndex);
      }
      return this._idFactory;
    }
  }]);
  return OperatorList;
}();
exports.OperatorList = OperatorList;
var Catalog = function () {
  function Catalog(pdfManager, xref, root) {
    _classCallCheck(this, Catalog);
    this.pdfManager = pdfManager;
    this.xref = xref;
    this.catDict = root;
    this.fontCache = new _primitives.RefSetCache();
    this.builtInCMapCache = new Map();
  }
  _createClass(Catalog, [{
    key: "numPages",
    get: function get() {
      var obj = this.catDict.get("Pages");
      if (!(0, _primitives.isDict)(obj)) {
        return 0;
      }
      return obj.get("Count");
    }
  }, {
    key: "destinations",
    get: function get() {
      var obj = this.catDict.get("Names");
      if (!(0, _primitives.isDict)(obj)) {
        return null;
      }
      return obj.get("Dests");
    }
  }, {
    key: "fontCollection",
    get: function get() {
      var obj = this.catDict.get("AcroForm");
      if (!(0, _primitives.isDict)(obj)) {
        return null;
      }
      return obj.get("DR");
    }
  }, {
    key: "getPage",
    value: function getPage(pageIndex) {
      var _this44 = this;
      return this.pdfManager.ensure(this, "getPageDict", [pageIndex]).then(function (pageDict) {
        if (!pageDict) {
          throw new Error("Page ".concat(pageIndex, " not found."));
        }
        var pageRef = _this44.getPageRef(pageIndex);
        var page = new Page({
          pdfManager: _this44.pdfManager,
          xref: _this44.xref,
          pageIndex: pageIndex,
          pageDict: pageDict,
          ref: pageRef,
          fontCache: _this44.fontCache,
          builtInCMapCache: _this44.builtInCMapCache
        });
        return page;
      });
    }
  }, {
    key: "getPageDict",
    value: function getPageDict(pageIndex) {
      var _this45 = this;
      var capability = (0, _util.createPromiseCapability)();
      var pages = this.catDict.get("Pages");
      var getPage = function getPage(kidRef, kids) {
        var kid = _this45.xref.fetch(kidRef);
        if (!(0, _primitives.isDict)(kid)) {
          capability.reject("Page dictionary is not a dictionary");
          return;
        }
        if (kid.has("Kids")) {
          var firstKid = kid.get("Kids")[0];
          if ((0, _primitives.isRef)(firstKid) && firstKid.num === kidRef.num && firstKid.gen === kidRef.gen) {
            capability.reject("Page tree has a cycle");
            return;
          }
          getPage(firstKid, kid.get("Kids"));
        } else {
          var count = kid.get("Count");
          if (pageIndex < count) {
            capability.resolve(kid);
          } else {
            pageIndex -= count;
            var nextKid = kids.shift();
            if (nextKid) {
              getPage(nextKid, kids);
            } else {
              capability.reject("Page not found");
            }
          }
        }
      };
      getPage(pages.get("Kids")[0], pages.get("Kids").slice(1));
      return capability.promise;
    }
  }, {
    key: "getPageRef",
    value: function getPageRef(pageIndex) {
      var pages = this.catDict.get("Pages");
      var kids = pages.get("Kids");
      var i, ii;
      for (i = 0, ii = kids.length; i < ii; i++) {
        var kid = kids[i];
        if ((0, _primitives.isRef)(kid)) {
          var dict = this.xref.fetch(kid);
          if ((0, _primitives.isDict)(dict) && dict.has("Kids")) {
            var count = dict.get("Count");
            if (pageIndex < count) {
              var subKids = dict.get("Kids");
              for (var j = 0, jj = subKids.length; j < jj; j++) {
                var subKid = subKids[j];
                if ((0, _primitives.isRef)(subKid)) {
                  var subDict = this.xref.fetch(subKid);
                  if ((0, _primitives.isDict)(subDict) && subDict.has("Kids")) {
                    var subCount = subDict.get("Count");
                    if (pageIndex < subCount) {
                      return this.getPageRefFromKids(subDict.get("Kids"), pageIndex);
                    }
                    pageIndex -= subCount;
                  } else if (pageIndex === 0) {
                    return subKid;
                  } else {
                    pageIndex--;
                  }
                }
              }
            }
            pageIndex -= count;
          } else if (pageIndex === 0) {
            return kid;
          } else {
            pageIndex--;
          }
        }
      }
      return null;
    }
  }, {
    key: "getPageRefFromKids",
    value: function getPageRefFromKids(kids, pageIndex) {
      for (var i = 0, ii = kids.length; i < ii; i++) {
        var kid = kids[i];
        if ((0, _primitives.isRef)(kid)) {
          var dict = this.xref.fetch(kid);
          if ((0, _primitives.isDict)(dict) && dict.has("Kids")) {
            var count = dict.get("Count");
            if (pageIndex < count) {
              return this.getPageRefFromKids(dict.get("Kids"), pageIndex);
            }
            pageIndex -= count;
          } else if (pageIndex === 0) {
            return kid;
          } else {
            pageIndex--;
          }
        }
      }
      return null;
    }
  }, {
    key: "getPageLabels",
    value: function getPageLabels() {
      var _this46 = this;
      var obj = this.catDict.get("PageLabels");
      if (!(0, _primitives.isDict)(obj)) {
        return null;
      }
      var nums = obj.get("Nums");
      if (!Array.isArray(nums)) {
        return null;
      }
      var labels = [];
      var numberTree = new _parser.NumberTree(nums, this.xref);
      numberTree.forEach(function (key, value) {
        var label = {
          style: "",
          prefix: "",
          start: 1
        };
        if ((0, _primitives.isDict)(value)) {
          var s = value.get("S");
          if ((0, _primitives.isName)(s)) {
            label.style = s.name;
          }
          var p = value.get("P");
          if (typeof p === "string") {
            label.prefix = p;
          }
          var st = value.get("St");
          if (Number.isInteger(st)) {
            label.start = st;
          }
        }
        labels.push(label);
      });
      return labels;
    }
  }]);
  return Catalog;
}();
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isEOF = isEOF;
exports.isCmd = isCmd;
exports.isDict = isDict;
exports.isName = isName;
exports.isRef = isRef;
exports.isStream = isStream;
exports.RefSetCache = exports.RefSet = exports.Name = exports.EOF = exports.Dict = exports.Cmd = void 0;
var _util = __webpack_require__(1);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var EOF = function EOF() {
  _classCallCheck(this, EOF);
};
exports.EOF = EOF;
var Name = function () {
  function Name(name) {
    _classCallCheck(this, Name);
    this.name = name;
  }
  _createClass(Name, [{
    key: "toString",
    value: function toString() {
      return this.name;
    }
  }], [{
    key: "get",
    value: function get(name) {
      var nameObj = this.cache[name];
      return nameObj || (this.cache[name] = new Name(name));
    }
  }, {
    key: "isName",
    value: function isName(v, name) {
      return v instanceof Name && (name === undefined || v.name === name);
    }
  }]);
  return Name;
}();
exports.Name = Name;
Name.cache = Object.create(null);
var Cmd = function () {
  function Cmd(cmd) {
    _classCallCheck(this, Cmd);
    this.cmd = cmd;
  }
  _createClass(Cmd, [{
    key: "toString",
    value: function toString() {
      return this.cmd;
    }
  }], [{
    key: "get",
    value: function get(cmd) {
      var cmdObj = this.cache[cmd];
      return cmdObj || (this.cache[cmd] = new Cmd(cmd));
    }
  }, {
    key: "isCmd",
    value: function isCmd(v, cmd) {
      return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
    }
  }]);
  return Cmd;
}();
exports.Cmd = Cmd;
Cmd.cache = Object.create(null);
var Dict = function () {
  function Dict(xref) {
    _classCallCheck(this, Dict);
    this.xref = xref;
    this._map = Object.create(null);
    this.objId = null;
  }
  _createClass(Dict, [{
    key: "size",
    get: function get() {
      return Object.keys(this._map).length;
    }
  }, {
    key: "get",
    value: function get(key) {
      var value = this._map[key];
      if (value !== undefined) {
        return this.xref.fetchIfRef(value);
      }
      return undefined;
    }
  }, {
    key: "getAsync",
    value: function getAsync(key) {
      var value = this._map[key];
      return this.xref.fetchIfRefAsync(value);
    }
  }, {
    key: "getArray",
    value: function getArray(key) {
      var value = this._map[key];
      if (value !== undefined) {
        return this.xref.fetchIfRef(value);
      }
      return undefined;
    }
  }, {
    key: "set",
    value: function set(key, value) {
      this._map[key] = value;
    }
  }, {
    key: "has",
    value: function has(key) {
      return key in this._map;
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      for (var key in this._map) {
        callback(key, this.get(key));
      }
    }
  }, {
    key: "toJSObject",
    value: function toJSObject() {
      var jsObject = Object.create(null);
      this.forEach(function (key, value) {
        if (value instanceof Dict) {
          jsObject[key] = value.toJSObject();
        } else {
          jsObject[key] = value;
        }
      });
      return jsObject;
    }
  }, {
    key: "clear",
    value: function clear() {
      this._map = Object.create(null);
    }
  }], [{
    key: "empty",
    get: function get() {
      var emptyDict = new Dict(null);
      (0, _util.shadow)(this, "empty", emptyDict);
      return emptyDict;
    }
  }, {
    key: "merge",
    value: function merge(xref, dicts) {
      var mergedDict = new Dict(xref);
      for (var i = 0, ii = dicts.length; i < ii; ++i) {
        var dict = dicts[i];
        if (!(dict instanceof Dict)) {
          continue;
        }
        for (var key in dict._map) {
          if (!mergedDict.has(key)) {
            mergedDict.set(key, dict._map[key]);
          }
        }
      }
      return mergedDict;
    }
  }]);
  return Dict;
}();
exports.Dict = Dict;
var Ref = function () {
  function Ref(num, gen) {
    _classCallCheck(this, Ref);
    this.num = num;
    this.gen = gen;
  }
  _createClass(Ref, [{
    key: "toString",
    value: function toString() {
      if (this.gen === 0) {
        return "".concat(this.num, "R");
      }
      return "".concat(this.num, "R").concat(this.gen);
    }
  }]);
  return Ref;
}();
function isEOF(v) {
  return v === EOF;
}
function isCmd(v, cmd) {
  return Cmd.isCmd(v, cmd);
}
function isDict(v, type) {
  return v instanceof Dict && (type === undefined || isName(v.get("Type"), type));
}
function isName(v, name) {
  return Name.isName(v, name);
}
function isRef(v) {
  return v instanceof Ref;
}
function isStream(v) {
  return _typeof(v) === "object" && v !== null && v.getBytes !== undefined;
}
var RefSet = function () {
  function RefSet() {
    var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    _classCallCheck(this, RefSet);
    this._set = Object.create(parent ? parent._set : null);
  }
  _createClass(RefSet, [{
    key: "put",
    value: function put(ref) {
      if ((0, _util.isObject)(ref)) {
        ref = ref.toString();
      }
      this._set[ref] = true;
    }
  }, {
    key: "putAll",
    value: function putAll(refs) {
      for (var i = 0, ii = refs.length; i < ii; i++) {
        this.put(refs[i]);
      }
    }
  }, {
    key: "has",
    value: function has(ref) {
      if ((0, _util.isObject)(ref)) {
        ref = ref.toString();
      }
      return !!this._set[ref];
    }
  }, {
    key: "clear",
    value: function clear() {
      this._set = Object.create(null);
    }
  }]);
  return RefSet;
}();
exports.RefSet = RefSet;
var RefSetCache = function (_RefSet) {
  _inherits(RefSetCache, _RefSet);
  var _super = _createSuper(RefSetCache);
  function RefSetCache() {
    _classCallCheck(this, RefSetCache);
    return _super.apply(this, arguments);
  }
  _createClass(RefSetCache, [{
    key: "get",
    value: function get(ref) {
      if ((0, _util.isObject)(ref)) {
        ref = ref.toString();
      }
      return this._set[ref];
    }
  }]);
  return RefSetCache;
}(RefSet);
exports.RefSetCache = RefSetCache;

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StreamsSequenceStream = exports.StreamReader = exports.StringStream = exports.Stream = exports.ReadableStream = exports.QueueingStream = exports.MakeLzwStream = exports.MakeJpxStream = exports.MakeJbig2Stream = exports.MakeFilter = exports.JpxImage = exports.EmptyStream = exports.DecodeStream = void 0;
var _util = __webpack_require__(1);
var _primitives = __webpack_require__(6);
var _parser = __webpack_require__(8);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var Stream = function () {
  function Stream(arrayBuffer, start, length, dict) {
    _classCallCheck(this, Stream);
    this.bytes = new Uint8Array(arrayBuffer);
    this.start = start || 0;
    this.pos = this.start;
    this.end = start + length || this.bytes.length;
    this.dict = dict;
  }
  _createClass(Stream, [{
    key: "length",
    get: function get() {
      return this.end - this.start;
    }
  }, {
    key: "getByte",
    value: function getByte() {
      if (this.pos >= this.end) {
        return -1;
      }
      return this.bytes[this.pos++];
    }
  }, {
    key: "getUint16",
    value: function getUint16() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return b0 << 8 | b1;
    }
  }, {
    key: "getInt32",
    value: function getInt32() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return b0 << 24 | b1 << 16 | b2 << 8 | b3;
    }
  }, {
    key: "getBytes",
    value: function getBytes(length) {
      var bytes = this.bytes;
      var pos = this.pos;
      var strEnd = this.end;
      if (!length) {
        if (pos >= strEnd) {
          return new Uint8Array(0);
        }
        var newPos = strEnd;
        this.pos = newPos;
        return bytes.subarray(pos, newPos);
      }
      var newPos = pos + length;
      if (newPos > strEnd) {
        newPos = strEnd;
      }
      this.pos = newPos;
      return bytes.subarray(pos, newPos);
    }
  }, {
    key: "peekByte",
    value: function peekByte() {
      var peekedByte = this.getByte();
      if (peekedByte !== -1) {
        this.pos--;
      }
      return peekedByte;
    }
  }, {
    key: "peekBytes",
    value: function peekBytes(length) {
      var bytes = this.getBytes(length);
      this.pos -= bytes.length;
      return bytes;
    }
  }, {
    key: "skip",
    value: function skip(n) {
      if (n === undefined) {
        n = 1;
      }
      this.pos += n;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.pos = this.start;
    }
  }, {
    key: "moveStart",
    value: function moveStart() {
      this.start = this.pos;
    }
  }, {
    key: "makeSubStream",
    value: function makeSubStream(start, length, dict) {
      return new Stream(this.bytes.buffer, start, length, dict);
    }
  }, {
    key: "getStream",
    value: function getStream() {
      return this;
    }
  }, {
    key: "get ",
    value: function get () {
      return this.getBytes();
    }
  }]);
  return Stream;
}();
exports.Stream = Stream;
var StringStream = function (_Stream) {
  _inherits(StringStream, _Stream);
  var _super = _createSuper(StringStream);
  function StringStream(str) {
    _classCallCheck(this, StringStream);
    var bytes = (0, _util.stringToBytes)(str);
    return _super.call(this, bytes.buffer, 0, bytes.length);
  }
  return _createClass(StringStream);
}(Stream);
exports.StringStream = StringStream;
var DecodeStream = function (_Stream2) {
  _inherits(DecodeStream, _Stream2);
  var _super2 = _createSuper(DecodeStream);
  function DecodeStream(stream) {
    var _this;
    _classCallCheck(this, DecodeStream);
    _this = _super2.call(this);
    _this.stream = stream;
    _this.dict = stream.dict;
    return _this;
  }
  _createClass(DecodeStream, [{
    key: "getFilters",
    value: function getFilters() {
      var filter = this.dict.get("Filter");
      var params = this.dict.get("DecodeParms");
      if (filter instanceof _primitives.Name) {
        return [{
          name: filter.name,
          params: params
        }];
      }
      var filters = [];
      if (Array.isArray(filter)) {
        var paramsArray = Array.isArray(params) ? params : [params];
        for (var i = 0, ii = filter.length; i < ii; ++i) {
          filters.push({
            name: filter[i].name,
            params: paramsArray[i]
          });
        }
      }
      return filters;
    }
  }, {
    key: "getZlib",
    value: function getZlib() {
      return this.stream.getZlib();
    }
  }]);
  return DecodeStream;
}(Stream);
exports.DecodeStream = DecodeStream;
var StreamsSequenceStream = function (_Stream3) {
  _inherits(StreamsSequenceStream, _Stream3);
  var _super3 = _createSuper(StreamsSequenceStream);
  function StreamsSequenceStream(streams) {
    var _this2;
    _classCallCheck(this, StreamsSequenceStream);
    _this2 = _super3.call(this);
    _this2.streams = streams;
    return _this2;
  }
  return _createClass(StreamsSequenceStream);
}(Stream);
exports.StreamsSequenceStream = StreamsSequenceStream;
function MakeFilter(filterName, params, xref) {
  switch (filterName) {
    case "FlateDecode":
    case "/Fl":
      return new FlateStream(null, params);
    case "LZWDecode":
    case "/LZW":
      return new LZWStream(null, params);
    case "RunLengthDecode":
    case "/RL":
      return new RunLengthStream(null, params);
    case "CCITTFaxDecode":
    case "/CCF":
      return new CCITTFaxStream(null, params);
    case "DCTDecode":
    case "/DCT":
      return new JpegStream(null, params, xref);
    case "JPXDecode":
    case "/JPX":
      return new JpxStream(null, params, xref);
    case "JBIG2Decode":
    case "/JBIG2":
      return new Jbig2Stream(null, params, xref);
    case "ASCIIHexDecode":
    case "/AHx":
      return new ASCIIHexStream(null, params);
    case "ASCII85Decode":
    case "/A85":
      return new ASCII85Stream(null, params);
    case "Crypt":
    case "/Crypt":
      return new CryptStream(null, params, xref);
    default:
      (0, _util.warn)("Filter ".concat(filterName, " is not supported"));
      return new NullStream(null, params);
  }
}
function MakeJbig2Stream(stream, params, xref) {
  var Jbig2Image = __webpack_require__(17).Jbig2Image;
  return new Jbig2Image(stream, params, xref);
}
function MakeJpxStream(stream, params, xref) {
  var JpxImage = __webpack_require__(18).JpxImage;
  return new JpxImage(stream, params, xref);
}
function MakeLzwStream(stream, params) {
  return new LZWStream(stream, params);
}
var FlateStream = function (_DecodeStream) {
  _inherits(FlateStream, _DecodeStream);
  var _super4 = _createSuper(FlateStream);
  function FlateStream(stream, params) {
    var _this3;
    _classCallCheck(this, FlateStream);
    _this3 = _super4.call(this, stream);
    _this3.flate = _this3.getZlib();
    _this3.flate.ondata = function (data) {
      _this3.buffer = data;
    };
    return _this3;
  }
  return _createClass(FlateStream);
}(DecodeStream);
var LZWStream = function (_DecodeStream2) {
  _inherits(LZWStream, _DecodeStream2);
  var _super5 = _createSuper(LZWStream);
  function LZWStream(stream, params) {
    var _this4;
    _classCallCheck(this, LZWStream);
    _this4 = _super5.call(this, stream);
    _this4.lzwState = {
      earlyChange: 0
    };
    if (params) {
      if (params.get("EarlyChange") === 0) {
        _this4.lzwState.earlyChange = 0;
      }
    }
    return _this4;
  }
  return _createClass(LZWStream);
}(DecodeStream);
var RunLengthStream = function (_DecodeStream3) {
  _inherits(RunLengthStream, _DecodeStream3);
  var _super6 = _createSuper(RunLengthStream);
  function RunLengthStream(stream, params) {
    _classCallCheck(this, RunLengthStream);
    return _super6.call(this, stream, params);
  }
  return _createClass(RunLengthStream);
}(DecodeStream);
var CCITTFaxStream = function (_DecodeStream4) {
  _inherits(CCITTFaxStream, _DecodeStream4);
  var _super7 = _createSuper(CCITTFaxStream);
  function CCITTFaxStream(stream, params) {
    _classCallCheck(this, CCITTFaxStream);
    return _super7.call(this, stream, params);
  }
  return _createClass(CCITTFaxStream);
}(DecodeStream);
var JpegStream = function (_DecodeStream5) {
  _inherits(JpegStream, _DecodeStream5);
  var _super8 = _createSuper(JpegStream);
  function JpegStream(stream, params, xref) {
    var _this5;
    _classCallCheck(this, JpegStream);
    _this5 = _super8.call(this, stream, params);
    var dict = stream.dict;
    var colorSpace = dict.get("ColorSpace");
    if (colorSpace) {
      _this5.colorSpace = _parser.ColorSpace.parse(colorSpace, xref, _this5.resources);
    }
    return _this5;
  }
  return _createClass(JpegStream);
}(DecodeStream);
var JpxStream = function (_DecodeStream6) {
  _inherits(JpxStream, _DecodeStream6);
  var _super9 = _createSuper(JpxStream);
  function JpxStream(stream, params, xref) {
    var _this6;
    _classCallCheck(this, JpxStream);
    _this6 = _super9.call(this, stream, params);
    var dict = stream.dict;
    var colorSpace = dict.get("ColorSpace");
    if (colorSpace) {
      _this6.colorSpace = _parser.ColorSpace.parse(colorSpace, xref, _this6.resources);
    }
    _this6.jpxImage = new JpxImage();
    return _this6;
  }
  return _createClass(JpxStream);
}(DecodeStream);
exports.MakeJpxStream = MakeJpxStream;
var JpxImage = function () {
  function JpxImage() {
    _classCallCheck(this, JpxImage);
  }
  _createClass(JpxImage, [{
    key: "parse",
    value: function parse(data, smask, alpha) {
      var jpxImage = new JpxImage();
      jpxImage.parse(data, smask, alpha);
      this.width = jpxImage.width;
      this.height = jpxImage.height;
      this.componentsCount = jpxImage.componentsCount;
      this.bpc = jpxImage.bpc;
      this.data = jpxImage.data;
    }
  }, {
    key: "getImages",
    value: function getImages() {
      return [this];
    }
  }]);
  return JpxImage;
}();
exports.JpxImage = JpxImage;
var Jbig2Stream = function (_DecodeStream7) {
  _inherits(Jbig2Stream, _DecodeStream7);
  var _super10 = _createSuper(Jbig2Stream);
  function Jbig2Stream(stream, params, xref) {
    var _this7;
    _classCallCheck(this, Jbig2Stream);
    _this7 = _super10.call(this, stream, params);
    var jbig2Globals = params ? params.get("JBIG2Globals") : null;
    if (jbig2Globals) {
      _this7.jbig2Image = new Jbig2Image(stream, params, xref);
    }
    return _this7;
  }
  return _createClass(Jbig2Stream);
}(DecodeStream);
exports.MakeJbig2Stream = MakeJbig2Stream;
var ASCIIHexStream = function (_DecodeStream8) {
  _inherits(ASCIIHexStream, _DecodeStream8);
  var _super11 = _createSuper(ASCIIHexStream);
  function ASCIIHexStream(stream, params) {
    _classCallCheck(this, ASCIIHexStream);
    return _super11.call(this, stream, params);
  }
  return _createClass(ASCIIHexStream);
}(DecodeStream);
var ASCII85Stream = function (_DecodeStream9) {
  _inherits(ASCII85Stream, _DecodeStream9);
  var _super12 = _createSuper(ASCII85Stream);
  function ASCII85Stream(stream, params) {
    _classCallCheck(this, ASCII85Stream);
    return _super12.call(this, stream, params);
  }
  return _createClass(ASCII85Stream);
}(DecodeStream);
var CryptStream = function (_DecodeStream10) {
  _inherits(CryptStream, _DecodeStream10);
  var _super13 = _createSuper(CryptStream);
  function CryptStream(stream, params, xref) {
    var _this8;
    _classCallCheck(this, CryptStream);
    _this8 = _super13.call(this, stream, params);
    _this8.cipher = new _parser.CipherTransform(stream.getBytes(), xref.encrypt);
    return _this8;
  }
  return _createClass(CryptStream);
}(DecodeStream);
var NullStream = function (_DecodeStream11) {
  _inherits(NullStream, _DecodeStream11);
  var _super14 = _createSuper(NullStream);
  function NullStream(stream, params) {
    _classCallCheck(this, NullStream);
    return _super14.call(this, stream, params);
  }
  return _createClass(NullStream);
}(DecodeStream);
var EmptyStream = function (_Stream4) {
  _inherits(EmptyStream, _Stream4);
  var _super15 = _createSuper(EmptyStream);
  function EmptyStream() {
    _classCallCheck(this, EmptyStream);
    return _super15.call(this, new Uint8Array(0));
  }
  return _createClass(EmptyStream);
}(Stream);
exports.EmptyStream = EmptyStream;
var QueueingStream = function (_Stream5) {
  _inherits(QueueingStream, _Stream5);
  var _super16 = _createSuper(QueueingStream);
  function QueueingStream(start, length, onData) {
    var _this9;
    _classCallCheck(this, QueueingStream);
    _this9 = _super16.call(this);
    _this9.start = start;
    _this9.end = start + length;
    _this9.onData = onData;
    _this9.buffer = [];
    _this9.highestPos = 0;
    return _this9;
  }
  return _createClass(QueueingStream);
}(Stream);
exports.QueueingStream = QueueingStream;
var ReadableStream = function (_Stream6) {
  _inherits(ReadableStream, _Stream6);
  var _super17 = _createSuper(ReadableStream);
  function ReadableStream(source, length) {
    var _this10;
    _classCallCheck(this, ReadableStream);
    _this10 = _super17.call(this);
    _this10.source = source;
    _this10.length = length;
    _this10.bytes = new Uint8Array(length);
    _this10.pos = 0;
    _this10.readCapability = (0, _util.createPromiseCapability)();
    return _this10;
  }
  return _createClass(ReadableStream);
}(Stream);
exports.ReadableStream = ReadableStream;
var StreamReader = function (_Stream7) {
  _inherits(StreamReader, _Stream7);
  var _super18 = _createSuper(StreamReader);
  function StreamReader(stream) {
    _classCallCheck(this, StreamReader);
    return _super18.call(this, stream.getBytes());
  }
  return _createClass(StreamReader);
}(Stream);
exports.StreamReader = StreamReader;

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XRef = exports.ParserState = exports.Parser = exports.PDFDocumentParser = exports.NumberTree = exports.Lexer = exports.Linearization = exports.IDFactory = exports.FileSpec = exports.ColorSpace = void 0;
var _util = __webpack_require__(1);
var _primitives = __webpack_require__(6);
var _stream = __webpack_require__(7);
var _crypto = __webpack_require__(9);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var Lexer = function () {
  function Lexer(stream) {
    _classCallCheck(this, Lexer);
    this.stream = stream;
  }
  _createClass(Lexer, [{
    key: "getObj",
    value: function getObj() {
      var stream = this.stream;
      var obj;
      var comment = false;
      while ((obj = stream.getByte()) !== -1) {
        if (comment) {
          if (obj === 0x0A || obj === 0x0D) {
            comment = false;
          }
          continue;
        }
        if (obj <= 0x20) {
          continue;
        }
        if (obj === 0x25) {
          comment = true;
          continue;
        }
        if (obj >= 0x30 && obj <= 0x39 || obj === 0x2E || obj === 0x2D) {
          return this.getNumber(obj);
        }
        if (obj === 0x28) {
          return this.getString(obj);
        }
        if (obj === 0x2F) {
          return this.getName(obj);
        }
        if (obj === 0x5B) {
          return this.getArray(obj);
        }
        if (obj === 0x3C) {
          if (stream.peekByte() === 0x3C) {
            return this.getDict(obj);
          }
          return this.getHexString(obj);
        }
        if (obj >= 0x61 && obj <= 0x7A || obj >= 0x41 && obj <= 0x5A) {
          return this.getCmd(obj);
        }
        if (obj === 0x3E) {
          if (stream.peekByte() === 0x3E) {
            stream.skip();
            return _primitives.Cmd.get(">>");
          }
          return _primitives.EOF;
        }
        if (obj === 0x5D) {
          return _primitives.Cmd.get("]");
        }
        if (obj === 0x7B) {
          return _primitives.Cmd.get("{");
        }
        if (obj === 0x7D) {
          return _primitives.Cmd.get("}");
        }
      }
      return _primitives.EOF;
    }
  }, {
    key: "getNumber",
    value: function getNumber(firstByte) {
      var str = String.fromCharCode(firstByte);
      var stream = this.stream;
      var ch;
      while ((ch = stream.peekByte()) !== -1) {
        if (ch >= 0x30 && ch <= 0x39 || ch === 0x2E) {
          str += String.fromCharCode(stream.getByte());
        } else {
          break;
        }
      }
      if (str.indexOf(".") !== -1) {
        return parseFloat(str);
      }
      return parseInt(str, 10);
    }
  }, {
    key: "getString",
    value: function getString(firstByte) {
      var str = "";
      var stream = this.stream;
      var ch;
      var parens = 1;
      while ((ch = stream.getByte()) !== -1) {
        if (ch === 0x28) {
          parens++;
        } else if (ch === 0x29) {
          parens--;
          if (parens === 0) {
            break;
          }
        } else if (ch === 0x5C) {
          ch = stream.getByte();
          if (ch === 0x6E) {
            ch = 0x0A;
          } else if (ch === 0x72) {
            ch = 0x0D;
          } else if (ch === 0x74) {
            ch = 0x09;
          } else if (ch === 0x62) {
            ch = 0x08;
          } else if (ch === 0x66) {
            ch = 0x0C;
          } else if (ch >= 0x30 && ch <= 0x37) {
            var octal = String.fromCharCode(ch);
            ch = stream.peekByte();
            if (ch >= 0x30 && ch <= 0x37) {
              octal += String.fromCharCode(stream.getByte());
              ch = stream.peekByte();
              if (ch >= 0x30 && ch <= 0x37) {
                octal += String.fromCharCode(stream.getByte());
              }
            }
            ch = parseInt(octal, 8);
          }
        }
        str += String.fromCharCode(ch);
      }
      return str;
    }
  }, {
    key: "getName",
    value: function getName(firstByte) {
      var str = "";
      var stream = this.stream;
      var ch;
      while ((ch = stream.getByte()) !== -1) {
        if (ch >= 0x21 && ch <= 0x7E && ch !== 0x23 && ch !== 0x28 && ch !== 0x29 && ch !== 0x3C && ch !== 0x3E && ch !== 0x5B && ch !== 0x5D && ch !== 0x7B && ch !== 0x7D && ch !== 0x2F && ch !== 0x25) {
          str += String.fromCharCode(ch);
        } else {
          stream.skip(-1);
          break;
        }
      }
      return _primitives.Name.get(str);
    }
  }, {
    key: "getHexString",
    value: function getHexString(firstByte) {
      var str = "";
      var stream = this.stream;
      var ch;
      while ((ch = stream.getByte()) !== -1) {
        if (ch === 0x3E) {
          break;
        }
        str += String.fromCharCode(ch);
      }
      if (str.length % 2 === 1) {
        str += "0";
      }
      var bytes = new Uint8Array(str.length / 2);
      for (var i = 0, ii = str.length; i < ii; i += 2) {
        bytes[i / 2] = parseInt(str.substring(i, i + 2), 16);
      }
      return new _stream.Stream(bytes);
    }
  }, {
    key: "getArray",
    value: function getArray(firstByte) {
      var arr = [];
      var obj;
      while ((obj = this.getObj()) !== _primitives.EOF && !(0, _primitives.isCmd)(obj, "]")) {
        arr.push(obj);
      }
      return arr;
    }
  }, {
    key: "getDict",
    value: function getDict(firstByte) {
      var dict = new _primitives.Dict(null);
      var key;
      var obj;
      while ((obj = this.getObj()) !== _primitives.EOF && !(0, _primitives.isCmd)(obj, ">>")) {
        if (key) {
          dict.set(key.name, obj);
          key = null;
        } else {
          key = obj;
        }
      }
      return dict;
    }
  }, {
    key: "getCmd",
    value: function getCmd(firstByte) {
      var str = String.fromCharCode(firstByte);
      var stream = this.stream;
      var ch;
      while ((ch = stream.peekByte()) !== -1) {
        if (ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch === 0x2A || ch === 0x27) {
          str += String.fromCharCode(stream.getByte());
        } else {
          break;
        }
      }
      return _primitives.Cmd.get(str);
    }
  }]);
  return Lexer;
}();
exports.Lexer = Lexer;
var Parser = function () {
  function Parser(_ref) {
    var lexer = _ref.lexer,
      xref = _ref.xref,
      _ref$allowStreams = _ref.allowStreams,
      allowStreams = _ref$allowStreams === void 0 ? false : _ref$allowStreams;
    _classCallCheck(this, Parser);
    this.lexer = lexer;
    this.xref = xref;
    this.allowStreams = allowStreams;
    this.state = null;
  }
  _createClass(Parser, [{
    key: "getObj",
    value: function getObj(cipherTransform) {
      if (this.state) {
        var obj = this.state.obj;
        this.state = null;
        return obj;
      }
      var obj = this.lexer.getObj();
      if ((0, _primitives.isCmd)(obj, "R")) {
        var num = this.state.obj;
        this.state = null;
        return new _primitives.Ref(num, this.getObj());
      }
      if (this.allowStreams && (0, _primitives.isCmd)(obj, "stream")) {
        return this.getStream(cipherTransform);
      }
      this.state = {
        obj: obj
      };
      return obj;
    }
  }, {
    key: "getStream",
    value: function getStream(cipherTransform) {
      var dict = this.getObj();
      var stream = new _stream.Stream(this.lexer.stream.getBytes(), this.lexer.stream.pos, dict.get("Length"), dict);
      if (cipherTransform) {
        stream = cipherTransform.createStream(stream);
      }
      return stream;
    }
  }]);
  return Parser;
}();
exports.Parser = Parser;
var Linearization = function () {
  function Linearization(stream) {
    _classCallCheck(this, Linearization);
    this.parser = new Parser({
      lexer: new Lexer(stream),
      xref: null
    });
    this.length = this.parser.getObj();
    this.linDict = this.parser.getObj();
    this.mainXRefEntriesOffset = this.linDict.get("O");
    this.pageCount = this.linDict.get("N");
    this.firstPage = this.linDict.get("P");
    this.firstPageOffset = this.linDict.get("E");
    this.hintStreamOffset = this.linDict.get("H");
  }
  _createClass(Linearization, [{
    key: "page",
    get: function get() {
      return this.firstPage;
    }
  }]);
  return Linearization;
}();
exports.Linearization = Linearization;
var XRef = function () {
  function XRef(stream, pdfManager) {
    _classCallCheck(this, XRef);
    this.stream = stream;
    this.pdfManager = pdfManager;
    this.entries = [];
    this.xrefstms = Object.create(null);
    this.cache = new _primitives.RefSetCache();
  }
  _createClass(XRef, [{
    key: "trailer",
    get: function get() {
      if (!this._trailer) {
        this.parse();
      }
      return this._trailer;
    }
  }, {
    key: "parse",
    value: function parse(recoveryMode) {
      var _this = this;
      var stream = this.stream;
      if (recoveryMode) {
        stream.pos = 0;
        var r = stream.get ();
        var i = r.length - 1;
        var startxref, trailer;
        while (i >= 0 && !startxref) {
          if (r[i] === 0x25 && r[i + 1] === 0x25 && r[i + 2] === 0x45 && r[i + 3] === 0x4F && r[i + 4] === 0x46) {
            var j = i - 1;
            while (j >= 0 && (r[j] === 0x0A || r[j] === 0x0D)) {
              j--;
            }
            startxref = parseInt(String.fromCharCode.apply(null, r.subarray(j, i)), 10);
            trailer = this.readTrailer(stream, j);
            break;
          }
          i--;
        }
        if (!startxref) {
          throw new _util.InvalidPDFException("Invalid PDF structure.");
        }
      } else {
        var _startxref = this.readStartxref(stream);
        var _trailer = this.readTrailer(stream, _startxref);
      }
      this._trailer = trailer;
      this.parseXRefTable(startxref);
      var prev = trailer.get("Prev");
      if (Number.isInteger(prev)) {
        this.parseXRefTable(prev);
      }
      var xRefStm = trailer.get("XRefStm");
      if (Number.isInteger(xRefStm)) {
        var byteOffset = stream.start;
        var streamPos = stream.pos;
        stream.pos = byteOffset + xRefStm;
        try {
          this.parseXRefStm(xRefStm);
        } catch (e) {
          if (e instanceof _util.MissingDataException) {
            throw e;
          }
          (0, _util.warn)("Invalid XRef stream");
        }
        stream.pos = streamPos;
      }
    }
  }, {
    key: "readStartxref",
    value: function readStartxref(stream) {
      var startxref = 0;
      stream.pos = stream.end - 1024;
      if (stream.pos < 0) {
        stream.pos = 0;
      }
      var r = stream.get ();
      var i = r.length - 1;
      while (i >= 0) {
        if (r[i] === 0x73 && r[i + 1] === 0x74 && r[i + 2] === 0x61 && r[i + 3] === 0x72 && r[i + 4] === 0x74 && r[i + 5] === 0x78 && r[i + 6] === 0x72 && r[i + 7] === 0x65 && r[i + 8] === 0x66) {
          i += 9;
          while (r[i] <= 0x20) {
            i++;
          }
          var j = i;
          while (r[j] >= 0x30 && r[j] <= 0x39) {
            j++;
          }
          startxref = parseInt(String.fromCharCode.apply(null, r.subarray(i, j)), 10);
          break;
        }
        i--;
      }
      return startxref;
    }
  }, {
    key: "readTrailer",
    value: function readTrailer(stream, startxref) {
      stream.pos = startxref;
      var parser = new Parser({
        lexer: new Lexer(stream),
        xref: this
      });
      var obj = parser.getObj();
      if (!(0, _primitives.isCmd)(obj, "xref")) {
        stream.pos = startxref;
        var startXRefParsed = this.readStartxref(stream);
        if (startXRefParsed > startxref) {
          throw new _util.InvalidPDFException("startxref is pointing to the wrong offset");
        }
        stream.pos = startxref;
      }
      var trailer = parser.getObj();
      if (!(0, _primitives.isDict)(trailer)) {
        throw new _util.InvalidPDFException("Invalid trailer object");
      }
      return trailer;
    }
  }, {
    key: "parseXRefTable",
    value: function parseXRefTable(startxref) {
      var stream = this.stream;
      stream.pos = startxref;
      var parser = new Parser({
        lexer: new Lexer(stream),
        xref: this
      });
      var obj = parser.getObj();
      if (!(0, _primitives.isCmd)(obj, "xref")) {
        throw new _util.InvalidPDFException("Invalid XRef table");
      }
      while (true) {
        var num = parser.getObj();
        var count = parser.getObj();
        if ((0, _primitives.isCmd)(count, "trailer")) {
          break;
        }
        if (!Number.isInteger(num) || !Number.isInteger(count)) {
          throw new _util.InvalidPDFException("Invalid XRef table");
        }
        for (var i = num; i < num + count; i++) {
          var offset = parser.getObj();
          var gen = parser.getObj();
          var type = parser.getObj();
          if (!(0, _primitives.isCmd)(type, "n") && !(0, _primitives.isCmd)(type, "f")) {
            throw new _util.InvalidPDFException("Invalid XRef entry");
          }
          if (!this.entries[i]) {
            this.entries[i] = {
              offset: offset,
              gen: gen,
              free: (0, _primitives.isCmd)(type, "f")
            };
          }
        }
      }
    }
  }, {
    key: "parseXRefStm",
    value: function parseXRefStm(start) {
      var stream = this.stream.makeSubStream(start, this.stream.length - start);
      var parser = new Parser({
        lexer: new Lexer(stream),
        xref: this,
        allowStreams: true
      });
      var objNum = parser.getObj();
      var objGen = parser.getObj();
      var obj = parser.getObj();
      if (!(0, _primitives.isCmd)(obj, "obj")) {
        throw new _util.InvalidPDFException("Invalid XRef stream");
      }
      var dict = parser.getObj();
      if (!(0, _primitives.isDict)(dict)) {
        throw new _util.InvalidPDFException("Invalid XRef stream");
      }
      var size = dict.get("Size");
      var index = dict.get("Index") || [0, size];
      var w = dict.get("W");
      var str = parser.getObj();
      if (!(0, _primitives.isStream)(str)) {
        throw new _util.InvalidPDFException("Invalid XRef stream");
      }
      this.xrefstms[start] = str;
      this._trailer = dict;
      var i, j;
      var bytes = str.getBytes();
      var bytesPos = 0;
      for (i = 0; i < index.length; i += 2) {
        var first = index[i];
        var n = index[i + 1];
        for (j = 0; j < n; j++) {
          var type = 0;
          for (var k = 0; k < w[0]; k++) {
            type = (type << 8) + bytes[bytesPos++];
          }
          var offset = 0;
          for (var _k = 0; _k < w[1]; _k++) {
            offset = (offset << 8) + bytes[bytesPos++];
          }
          var gen = 0;
          for (var _k2 = 0; _k2 < w[2]; _k2++) {
            gen = (gen << 8) + bytes[bytesPos++];
          }
          if (type === 1) {
            if (!this.entries[first + j]) {
              this.entries[first + j] = {
                offset: offset,
                gen: gen,
                free: false
              };
            }
          } else if (type === 2) {
            this.xrefstms[offset] = true;
          }
        }
      }
    }
  }, {
    key: "fetchIfRef",
    value: function fetchIfRef(obj) {
      if (!(0, _primitives.isRef)(obj)) {
        return obj;
      }
      return this.fetch(obj);
    }
  }, {
    key: "fetchIfRefAsync",
    value: function fetchIfRefAsync(obj) {
      var _this2 = this;
      if (!(0, _primitives.isRef)(obj)) {
        return Promise.resolve(obj);
      }
      return new Promise(function (resolve) {
        _this2.pdfManager.request(function () {
          resolve(_this2.fetch(obj));
        });
      });
    }
  }, {
    key: "fetch",
    value: function fetch(ref, suppressEncryption) {
      var num = ref.num;
      if (this.cache.has(ref)) {
        var cacheEntry = this.cache.get(ref);
        if (cacheEntry instanceof _primitives.Dict) {
          if (!suppressEncryption && cacheEntry.encrypt) {
            return cacheEntry.encrypt;
          }
        }
        return cacheEntry;
      }
      var a = this.entries[num];
      if (!a) {
        return null;
      }
      var stream = this.stream.makeSubStream(a.offset);
      var parser = new Parser({
        lexer: new Lexer(stream),
        xref: this,
        allowStreams: true
      });
      var obj1 = parser.getObj();
      var obj2 = parser.getObj();
      var obj3 = parser.getObj();
      if (obj1 !== num || obj2 !== a.gen || !(0, _primitives.isCmd)(obj3, "obj")) {
        throw new _util.InvalidPDFException("Invalid object");
      }
      var obj = parser.getObj();
      if ((0, _primitives.isDict)(obj)) {
        obj.objId = ref;
      }
      this.cache.put(ref, obj);
      return obj;
    }
  }, {
    key: "getPermissions",
    value: function getPermissions() {
      var _this3 = this;
      return new Promise(function (resolve, reject) {
        _this3.pdfManager.request(function () {
          var encrypt = _this3.trailer.get("Encrypt");
          if (!encrypt) {
            resolve(null);
            return;
          }
          var perms = encrypt.get("P");
          if (perms) {
            resolve(perms);
          } else {
            resolve(null);
          }
        });
      });
    }
  }]);
  return XRef;
}();
exports.XRef = XRef;
var PDFDocumentParser = function () {
  function PDFDocumentParser(_ref2) {
    var stream = _ref2.stream,
      owner = _ref2.owner,
      xref = _ref2.xref,
      password = _ref2.password,
      docBaseUrl = _ref2.docBaseUrl;
    _classCallCheck(this, PDFDocumentParser);
    this.stream = stream;
    this.owner = owner;
    this.xref = xref;
    this.password = password;
    this.docBaseUrl = docBaseUrl;
    this.pdfInfo = {
      fingerprint: null,
      numPages: 0,
      xref: null,
      catalog: null,
      linearization: null,
      encrypted: false,
      permissions: null
    };
  }
  _createClass(PDFDocumentParser, [{
    key: "parse",
    value: function parse() {
      this.xref = new XRef(this.stream, this.owner);
      this.xref.parse();
      this.pdfInfo.xref = this.xref;
      var trailer = this.xref.trailer;
      var encrypt = trailer.get("Encrypt");
      if ((0, _primitives.isDict)(encrypt)) {
        this.pdfInfo.encrypted = true;
        this.xref.encrypt = new _crypto.CipherTransformFactory(encrypt, this.password);
      }
      var root = trailer.get("Root");
      if (!(0, _primitives.isDict)(root)) {
        throw new _util.InvalidPDFException("Invalid root dictionary.");
      }
      this.pdfInfo.catalog = new Catalog(this.owner, this.xref, root);
      this.pdfInfo.numPages = this.pdfInfo.catalog.numPages;
    }
  }, {
    key: "getLinearization",
    value: function getLinearization() {
      var stream = this.stream.makeSubStream(0, 32);
      var lexer = new Lexer(stream);
      var parser = new Parser({
        lexer: lexer,
        xref: null
      });
      var obj1 = parser.getObj();
      var obj2 = parser.getObj();
      var obj3 = parser.getObj();
      var obj4 = parser.getObj();
      if (Number.isInteger(obj1) && (0, _primitives.isCmd)(obj2, "obj") && (0, _primitives.isDict)(obj3) && (0, _primitives.isCmd)(obj4, "endobj")) {
        var linearization = new Linearization(stream);
        if (linearization.length === this.stream.length) {
          this.pdfInfo.linearization = linearization;
          return linearization;
        }
      }
      return null;
    }
  }, {
    key: "getDownloadInfo",
    value: function getDownloadInfo() {
      return Promise.resolve({
        length: this.stream.length
      });
    }
  }, {
    key: "getAttachments",
    value: function getAttachments() {
      return this.pdfInfo.catalog.getAttachments();
    }
  }, {
    key: "getJavaScript",
    value: function getJavaScript() {
      return this.pdfInfo.catalog.getJavaScript();
    }
  }, {
    key: "getOutline",
    value: function getOutline() {
      return this.pdfInfo.catalog.getOutline();
    }
  }, {
    key: "getPermissions",
    value: function getPermissions() {
      return this.xref.getPermissions();
    }
  }, {
    key: "getDestinations",
    value: function getDestinations() {
      return this.pdfInfo.catalog.getDestinations();
    }
  }, {
    key: "getOptionalContentConfig",
    value: function getOptionalContentConfig() {
      return this.pdfInfo.catalog.getOptionalContentConfig();
    }
  }, {
    key: "getXfa",
    value: function getXfa() {
      return this.pdfInfo.catalog.getXfa();
    }
  }, {
    key: "getMetadata",
    value: function getMetadata() {
      var _this4 = this;
      return new Promise(function (resolve) {
        var info = _this4.xref.trailer.get("Info") || _primitives.Dict.empty;
        resolve({
          info: info.toJSObject(),
          metadata: null
        });
      });
    }
  }]);
  return PDFDocumentParser;
}();
exports.PDFDocumentParser = PDFDocumentParser;
var NumberTree = function () {
  function NumberTree(root, xref) {
    _classCallCheck(this, NumberTree);
    function walk(node) {
      if ((0, _primitives.isDict)(node)) {
        var kids = node.get("Kids");
        if (Array.isArray(kids)) {
          for (var i = 0, ii = kids.length; i < ii; i++) {
            walk(xref.fetch(kids[i]));
          }
          return;
        }
        var nums = node.get("Nums");
        if (Array.isArray(nums)) {
          for (var _i = 0, _ii = nums.length; _i < _ii; _i += 2) {
            this.add(nums[_i], xref.fetch(nums[_i + 1]));
          }
        }
      }
    }
    this.map = Object.create(null);
    walk.call(this, root);
  }
  _createClass(NumberTree, [{
    key: "add",
    value: function add(num, value) {
      this.map[num] = value;
    }
  }, {
    key: "get",
    value: function get(num) {
      return this.map[num];
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      for (var num in this.map) {
        callback(parseInt(num, 10), this.map[num]);
      }
    }
  }]);
  return NumberTree;
}();
exports.NumberTree = NumberTree;
var ColorSpace = function () {
  function ColorSpace() {
    _classCallCheck(this, ColorSpace);
  }
  _createClass(ColorSpace, null, [{
    key: "parse",
    value: function parse(cs, xref, resources, pdfManager) {
      if ((0, _primitives.isName)(cs)) {
        switch (cs.name) {
          case "DeviceGray":
          case "G":
            return this.singletons.gray;
          case "DeviceRGB":
          case "RGB":
            return this.singletons.rgb;
          case "DeviceCMYK":
          case "CMYK":
            return this.singletons.cmyk;
          case "Pattern":
            return new PatternCS(null, null, pdfManager);
        }
      } else if (Array.isArray(cs)) {
        var mode = cs[0].name;
        var params, numComps;
        switch (mode) {
          case "DeviceGray":
          case "G":
            return this.singletons.gray;
          case "DeviceRGB":
          case "RGB":
            return this.singletons.rgb;
          case "DeviceCMYK":
          case "CMYK":
            return this.singletons.cmyk;
          case "CalGray":
            return new CalGrayCS(cs[1], xref);
          case "CalRGB":
            return new CalRGBCS(cs[1], xref);
          case "Lab":
            return new LabCS(cs[1], xref);
          case "ICCBased":
            var stream = xref.fetch(cs[1]);
            return new ICCBasedCS(stream.getBytes(), xref);
          case "Indexed":
            var baseCS = this.parse(cs[1], xref, resources, pdfManager);
            var hiVal = cs[2];
            var lookup = cs[3];
            if ((0, _primitives.isStream)(lookup)) {
              lookup = lookup.getBytes();
            }
            return new IndexedCS(baseCS, hiVal, lookup);
          case "Pattern":
            var patternCS = cs.length > 1 ? this.parse(cs[1], xref, resources, pdfManager) : null;
            return new PatternCS(null, patternCS, pdfManager);
          case "Separation":
            var name = cs[1].name;
            var altCS = this.parse(cs[2], xref, resources, pdfManager);
            var tintFn = xref.fetch(cs[3]);
            return new SeparationCS(name, altCS, tintFn);
          case "DeviceN":
            var names = cs[1];
            var _altCS = this.parse(cs[2], xref, resources, pdfManager);
            var _tintFn = xref.fetch(cs[3]);
            var attrs = cs[4];
            return new DeviceNCS(names, _altCS, _tintFn, attrs);
        }
      }
      throw new Error("Unrecognized color space: " + cs);
    }
  }, {
    key: "get",
    value: function get(name, xref, resources, pdfManager) {
      if (!name) {
        return this.singletons.gray;
      }
      if ((0, _primitives.isName)(name)) {
        return this.parse(name, xref, resources, pdfManager);
      }
      var cs = resources.get("ColorSpace").get(name.name);
      if (cs) {
        return this.parse(cs, xref, resources, pdfManager);
      }
      return this.parse(name, xref, resources, pdfManager);
    }
  }, {
    key: "singletons",
    get: function get() {
      return {
        gray: new DeviceGrayCS(),
        rgb: new DeviceRGBCS(),
        cmyk: new DeviceCMYKCS()
      };
    }
  }]);
  return ColorSpace;
}();
exports.ColorSpace = ColorSpace;
var DeviceGrayCS = function () {
  function DeviceGrayCS() {
    _classCallCheck(this, DeviceGrayCS);
    this.name = "DeviceGray";
    this.numComps = 1;
  }
  _createClass(DeviceGrayCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      var c = src[srcOffset];
      return [c, c, c];
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      var c = src[srcOffset];
      dest[destOffset] = c;
      dest[destOffset + 1] = c;
      dest[destOffset + 2] = c;
    }
  }]);
  return DeviceGrayCS;
}();
var DeviceRGBCS = function () {
  function DeviceRGBCS() {
    _classCallCheck(this, DeviceRGBCS);
    this.name = "DeviceRGB";
    this.numComps = 3;
  }
  _createClass(DeviceRGBCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      return [src[srcOffset], src[srcOffset + 1], src[srcOffset + 2]];
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      dest[destOffset] = src[srcOffset];
      dest[destOffset + 1] = src[srcOffset + 1];
      dest[destOffset + 2] = src[srcOffset + 2];
    }
  }]);
  return DeviceRGBCS;
}();
var DeviceCMYKCS = function () {
  function DeviceCMYKCS() {
    _classCallCheck(this, DeviceCMYKCS);
    this.name = "DeviceCMYK";
    this.numComps = 4;
  }
  _createClass(DeviceCMYKCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      var c = src[srcOffset];
      var m = src[srcOffset + 1];
      var y = src[srcOffset + 2];
      var k = src[srcOffset + 3];
      return [255 * (1 - c) * (1 - k), 255 * (1 - m) * (1 - k), 255 * (1 - y) * (1 - k)];
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      var c = src[srcOffset];
      var m = src[srcOffset + 1];
      var y = src[srcOffset + 2];
      var k = src[srcOffset + 3];
      dest[destOffset] = 255 * (1 - c) * (1 - k);
      dest[destOffset + 1] = 255 * (1 - m) * (1 - k);
      dest[destOffset + 2] = 255 * (1 - y) * (1 - k);
    }
  }]);
  return DeviceCMYKCS;
}();
var CalGrayCS = function (_DeviceGrayCS) {
  _inherits(CalGrayCS, _DeviceGrayCS);
  var _super = _createSuper(CalGrayCS);
  function CalGrayCS(params, xref) {
    var _this5;
    _classCallCheck(this, CalGrayCS);
    _this5 = _super.call(this);
    _this5.name = "CalGray";
    return _this5;
  }
  return _createClass(CalGrayCS);
}(DeviceGrayCS);
var CalRGBCS = function (_DeviceRGBCS) {
  _inherits(CalRGBCS, _DeviceRGBCS);
  var _super2 = _createSuper(CalRGBCS);
  function CalRGBCS(params, xref) {
    var _this6;
    _classCallCheck(this, CalRGBCS);
    _this6 = _super2.call(this);
    _this6.name = "CalRGB";
    return _this6;
  }
  return _createClass(CalRGBCS);
}(DeviceRGBCS);
var LabCS = function (_ColorSpace) {
  _inherits(LabCS, _ColorSpace);
  var _super3 = _createSuper(LabCS);
  function LabCS(params, xref) {
    var _this7;
    _classCallCheck(this, LabCS);
    _this7 = _super3.call(this);
    _this7.name = "Lab";
    _this7.numComps = 3;
    return _this7;
  }
  return _createClass(LabCS);
}(ColorSpace);
var ICCBasedCS = function (_ColorSpace2) {
  _inherits(ICCBasedCS, _ColorSpace2);
  var _super4 = _createSuper(ICCBasedCS);
  function ICCBasedCS(stream, xref) {
    var _this8;
    _classCallCheck(this, ICCBasedCS);
    _this8 = _super4.call(this);
    var dict = stream.dict;
    _this8.numComps = dict.get("N");
    var alt = dict.get("Alternate");
    if (alt) {
      _this8.alt = ColorSpace.parse(alt, xref);
    }
    _this8.name = "ICCBased";
    return _this8;
  }
  return _createClass(ICCBasedCS);
}(ColorSpace);
var IndexedCS = function (_ColorSpace3) {
  _inherits(IndexedCS, _ColorSpace3);
  var _super5 = _createSuper(IndexedCS);
  function IndexedCS(base, hival, lookup) {
    var _this9;
    _classCallCheck(this, IndexedCS);
    _this9 = _super5.call(this);
    _this9.base = base;
    _this9.hival = hival;
    _this9.lookup = lookup;
    _this9.name = "Indexed";
    _this9.numComps = 1;
    return _this9;
  }
  return _createClass(IndexedCS);
}(ColorSpace);
var PatternCS = function (_ColorSpace4) {
  _inherits(PatternCS, _ColorSpace4);
  var _super6 = _createSuper(PatternCS);
  function PatternCS(name, base, pdfManager) {
    var _this10;
    _classCallCheck(this, PatternCS);
    _this10 = _super6.call(this);
    _this10.name = "Pattern";
    _this10.base = base;
    _this10.pdfManager = pdfManager;
    return _this10;
  }
  return _createClass(PatternCS);
}(ColorSpace);
var SeparationCS = function (_ColorSpace5) {
  _inherits(SeparationCS, _ColorSpace5);
  var _super7 = _createSuper(SeparationCS);
  function SeparationCS(name, alt, tintFn) {
    var _this11;
    _classCallCheck(this, SeparationCS);
    _this11 = _super7.call(this);
    _this11.name = "Separation";
    _this11.alt = alt;
    _this11.tintFn = tintFn;
    _this11.numComps = 1;
    return _this11;
  }
  return _createClass(SeparationCS);
}(ColorSpace);
var DeviceNCS = function (_ColorSpace6) {
  _inherits(DeviceNCS, _ColorSpace6);
  var _super8 = _createSuper(DeviceNCS);
  function DeviceNCS(names, alt, tintFn, attrs) {
    var _this12;
    _classCallCheck(this, DeviceNCS);
    _this12 = _super8.call(this);
    _this12.names = names;
    _this12.alt = alt;
    _this12.tintFn = tintFn;
    _this12.attrs = attrs;
    _this12.name = "DeviceN";
    _this12.numComps = names.length;
    return _this12;
  }
  return _createClass(DeviceNCS);
}(ColorSpace);
var FileSpec = function () {
  function FileSpec(fileSpec, xref) {
    _classCallCheck(this, FileSpec);
    if (!(0, _primitives.isDict)(fileSpec)) {
      return;
    }
    this.filename = fileSpec.get("F");
    this.content = null;
    var ef = fileSpec.get("EF");
    if ((0, _primitives.isDict)(ef)) {
      var f = ef.get("F");
      if ((0, _primitives.isStream)(f)) {
        this.content = f.getBytes();
      }
    }
  }
  _createClass(FileSpec, null, [{
    key: "get",
    value: function get(fileSpec, xref) {
      if ((0, _primitives.isDict)(fileSpec)) {
        return new FileSpec(fileSpec, xref);
      }
      return null;
    }
  }]);
  return FileSpec;
}();
exports.FileSpec = FileSpec;
var IDFactory = function () {
  function IDFactory(pageIndex) {
    _classCallCheck(this, IDFactory);
    this.pageIndex = pageIndex;
    this.uniqueId = 0;
  }
  _createClass(IDFactory, [{
    key: "createId",
    value: function createId() {
      return "p".concat(this.pageIndex, "_").concat(this.uniqueId++);
    }
  }]);
  return IDFactory;
}();
exports.IDFactory = IDFactory;
var ParserState = function () {
  function ParserState() {
    _classCallCheck(this, ParserState);
    this.font = null;
    this.fontSize = 0;
    this.textMatrix = [1, 0, 0, 1, 0, 0];
    this.textLineMatrix = [1, 0, 0, 1, 0, 0];
    this.ctm = [1, 0, 0, 1, 0, 0];
    this.lineDash = [];
    this.lineCap = 0;
    this.lineJoin = 0;
    this.miterLimit = 0;
    this.fillColorSpace = new DeviceGrayCS();
    this.strokeColorSpace = new DeviceGrayCS();
    this.fillColor = [0, 0, 0];
    this.strokeColor = [0, 0, 0];
    this.textRenderingMode = 0;
  }
  _createClass(ParserState, [{
    key: "clone",
    value: function clone() {
      return Object.create(this);
    }
  }]);
  return ParserState;
}();
exports.ParserState = ParserState;

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createCipherFactory = createCipherFactory;
exports.createMD5 = createMD5;
exports.isAscii = isAscii;
exports.isWhiteSpace = isWhiteSpace;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function createCipherFactory(name, key) {
  var iv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (name !== "AES-128-CBC") {
    throw new Error("Unsupported cipher: ".concat(name));
  }
  if (!key) {
    throw new Error("Missing key");
  }
  return new AESCipherFactory(key, iv);
}
var AESCipherFactory = function () {
  function AESCipherFactory(key, iv) {
    _classCallCheck(this, AESCipherFactory);
    this.key = key;
    this.iv = iv;
  }
  _createClass(AESCipherFactory, [{
    key: "createCipher",
    value: function createCipher() {
      return new AESCipher(this.key, this.iv);
    }
  }, {
    key: "createDecipher",
    value: function createDecipher() {
      return new AESCipher(this.key, this.iv);
    }
  }]);
  return AESCipherFactory;
}();
var AESCipher = function () {
  function AESCipher(key, iv) {
    _classCallCheck(this, AESCipher);
    this.key = key;
    this.iv = iv;
  }
  _createClass(AESCipher, [{
    key: "update",
    value: function update(data) {
      return data;
    }
  }, {
    key: "finish",
    value: function finish() {
      return "";
    }
  }]);
  return AESCipher;
}();
function createMD5() {
  var _crypto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  if (_crypto && _crypto.createHash) {
    return _crypto.createHash("md5");
  }
  return new MD5();
}
var MD5 = function () {
  function MD5() {
    _classCallCheck(this, MD5);
    this.data = "";
  }
  _createClass(MD5, [{
    key: "update",
    value: function update(data) {
      this.data += data;
    }
  }, {
    key: "digest",
    value: function digest(encoding) {
      var _require = __webpack_require__(20),
        md5 = _require.md5;
      var hash = md5(this.data, {
        asBytes: true,
        asString: false
      });
      if (encoding === "hex") {
        var hex = "";
        for (var i = 0, ii = hash.length; i < ii; i++) {
          var h = hash[i].toString(16);
          if (h.length < 2) {
            h = "0" + h;
          }
          hex += h;
        }
        return hex;
      }
      return hash;
    }
  }]);
  return MD5;
}();
var ARC4 = function () {
  function ARC4(key) {
    _classCallCheck(this, ARC4);
    this.s = new Uint8Array(256);
    this.i = 0;
    this.j = 0;
    var s = this.s;
    for (var i = 0; i < 256; i++) {
      s[i] = i;
    }
    var j = 0,
      t;
    for (var _i = 0; _i < 256; _i++) {
      j = (j + s[_i] + key[_i % key.length]) & 255;
      t = s[_i];
      s[_i] = s[j];
      s[j] = t;
    }
  }
  _createClass(ARC4, [{
    key: "encrypt",
    value: function encrypt(data) {
      var s = this.s;
      var i = this.i;
      var j = this.j;
      var t;
      var encrypted = new Uint8Array(data.length);
      for (var k = 0, kk = data.length; k < kk; k++) {
        i = i + 1 & 255;
        j = j + s[i] & 255;
        t = s[i];
        s[i] = s[j];
        s[j] = t;
        encrypted[k] = data[k] ^ s[t + s[i] & 255];
      }
      this.i = i;
      this.j = j;
      return encrypted;
    }
  }]);
  return ARC4;
}();
function isWhiteSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
}
function isAscii(ch) {
  return (ch & 0xFFFFFF80) === 0;
}
var PasswordException = function (_Error) {
  function PasswordException(message, code) {
    _classCallCheck(this, PasswordException);
    return _call(this, _super.apply(this, arguments), message);
  }
  return _createClass(PasswordException);
}(_wrapError(Error));
function _wrapError(w) {
  var c = function c(a) {
    for (var _len = arguments.length, b = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      b[_key - 1] = arguments[_key];
    }
    a instanceof w ? w.apply(this, [a].concat(b)) : w.call(this, a);
  };
  c.prototype = Object.create(w.prototype, {
    constructor: {
      value: c
    },
    [Symbol.toStringTag]: {
      value: "Error"
    }
  });
  return c;
}
function _call(self, obj, arg) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return obj;
}

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isNodeJS = void 0;
var _util = __webpack_require__(1);
var isNodeJS = (0, _util.isNodeJS)();
exports.isNodeJS = isNodeJS;

/***/ }),
/* 11 */,
/* 12 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bidi = bidi;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var BidiText = function () {
  function BidiText(data, startLevel, rtl) {
    _classCallCheck(this, BidiText);
    this.data = data;
    this.startLevel = startLevel;
    this.rtl = rtl;
  }
  _createClass(BidiText, [{
    key: "getLevels",
    value: function getLevels() {
      var data = this.data;
      var levels = [];
      for (var i = 0, ii = data.length; i < ii; i++) {
        var ch = data[i];
        if (ch >= 0x0590 && ch <= 0x05f4) {
          levels.push(1);
        } else if (ch >= 0x0600 && ch <= 0x06ff) {
          levels.push(1);
        } else {
          levels.push(0);
        }
      }
      return levels;
    }
  }, {
    key: "getReorderedIndices",
    value: function getReorderedIndices(levels) {
      var indices = [];
      var i,
        ii,
        j,
        jj,
        start,
        end,
        level,
        prevLevel = 0;
      var data = this.data;
      var len = data.length;
      for (i = 0; i < len; i++) {
        indices.push(i);
      }
      for (i = 0, ii = levels.length; i < ii; i++) {
        level = levels[i];
        if (level > prevLevel) {
          start = i;
          while (i < ii && levels[i] >= level) {
            i++;
          }
          end = i - 1;
          for (j = start, jj = end; j < jj; j++, jj--) {
            var temp = indices[j];
            indices[j] = indices[jj];
            indices[jj] = temp;
          }
        }
        prevLevel = level;
      }
      return indices;
    }
  }]);
  return BidiText;
}();
function bidi(data, startLevel, rtl) {
  var bidiText = new BidiText(data, startLevel, rtl);
  var levels = bidiText.getLevels();
  var reordered = bidiText.getReorderedIndices(levels);
  return {
    str: reordered.map(function (i) {
      return data[i];
    }).join(""),
    dir: rtl ? "rtl" : "ltr",
    levels: levels
  };
}

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ColorSpace = void 0;
var _util = __webpack_require__(1);
var _primitives = __webpack_require__(6);
var _stream = __webpack_require__(7);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var ColorSpace = function () {
  function ColorSpace() {
    _classCallCheck(this, ColorSpace);
  }
  _createClass(ColorSpace, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      throw new Error("Abstract method ColorSpace.getRgb");
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      throw new Error("Abstract method ColorSpace.getRgbBuffer");
    }
  }, {
    key: "usesZeroToOneRange",
    get: function get() {
      return (0, _util.shadow)(this, "usesZeroToOneRange", true);
    }
  }], [{
    key: "parseAsync",
    value: function parseAsync(_ref) {
      var cs = _ref.cs,
        xref = _ref.xref,
        resources = _ref.resources,
        pdfManager = _ref.pdfManager,
        local = _ref.local;
      var aname;
      if ((0, _primitives.isName)(cs)) {
        aname = cs;
        cs = cs.name;
      }
      var promise;
      if (local) {
        var _cs = resources.get("ColorSpace");
        if (_cs) {
          var res = _cs.get(cs);
          if (res) {
            if ((0, _primitives.isName)(res)) {
              cs = res.name;
            } else {
              cs = res;
            }
          }
        }
      }
      if (typeof cs === "string") {
        switch (cs) {
          case "DeviceGray":
          case "G":
            promise = Promise.resolve(this.singletons.gray);
            break;
          case "DeviceRGB":
          case "RGB":
            promise = Promise.resolve(this.singletons.rgb);
            break;
          case "DeviceCMYK":
          case "CMYK":
            promise = Promise.resolve(this.singletons.cmyk);
            break;
          case "Pattern":
            promise = Promise.resolve(new PatternCS(null, null, pdfManager));
            break;
          default:
            promise = Promise.reject(new Error("Unrecognised colorspace name: ".concat(cs)));
            break;
        }
      } else if (Array.isArray(cs)) {
        var mode = cs[0].name;
        switch (mode) {
          case "DeviceGray":
          case "G":
            promise = Promise.resolve(this.singletons.gray);
            break;
          case "DeviceRGB":
          case "RGB":
            promise = Promise.resolve(this.singletons.rgb);
            break;
          case "DeviceCMYK":
          case "CMYK":
            promise = Promise.resolve(this.singletons.cmyk);
            break;
          case "CalGray":
            promise = Promise.resolve(new CalGrayCS(cs[1], xref));
            break;
          case "CalRGB":
            promise = Promise.resolve(new CalRGBCS(cs[1], xref));
            break;
          case "Lab":
            promise = Promise.resolve(new LabCS(cs[1], xref));
            break;
          case "ICCBased":
            var stream = xref.fetchIfRef(cs[1]);
            promise = Promise.resolve(new ICCBasedCS(stream, xref, resources));
            break;
          case "Indexed":
            var baseCS = this.parseAsync({
              cs: cs[1],
              xref: xref,
              resources: resources,
              pdfManager: pdfManager,
              local: local
            });
            var hiVal = cs[2];
            var lookup = cs[3];
            if ((0, _primitives.isStream)(lookup)) {
              lookup = lookup.getBytes();
            }
            promise = baseCS.then(function (base) {
              return new IndexedCS(base, hiVal, lookup);
            });
            break;
          case "Pattern":
            var patternPromise = cs.length > 1 ? this.parseAsync({
              cs: cs[1],
              xref: xref,
              resources: resources,
              pdfManager: pdfManager,
              local: local
            }) : Promise.resolve(null);
            promise = patternPromise.then(function (patternCS) {
              return new PatternCS(aname, patternCS, pdfManager);
            });
            break;
          case "Separation":
            var name = cs[1].name;
            var altPromise = this.parseAsync({
              cs: cs[2],
              xref: xref,
              resources: resources,
              pdfManager: pdfManager,
              local: local
            });
            var tintFn = xref.fetchIfRef(cs[3]);
            promise = altPromise.then(function (altCS) {
              return new SeparationCS(name, altCS, tintFn);
            });
            break;
          case "DeviceN":
            var names = cs[1];
            var _altPromise = this.parseAsync({
              cs: cs[2],
              xref: xref,
              resources: resources,
              pdfManager: pdfManager,
              local: local
            });
            var _tintFn = xref.fetchIfRef(cs[3]);
            var attrs = cs[4];
            promise = _altPromise.then(function (altCS) {
              return new DeviceNCS(names, altCS, _tintFn, attrs);
            });
            break;
          default:
            promise = Promise.reject(new Error("Unrecognised colorspace name: ".concat(mode)));
            break;
        }
      } else {
        promise = Promise.reject(new Error("Unrecognised colorspace: ".concat(cs)));
      }
      return promise.then(function (colorspace) {
        if (aname) {
          colorspace.name = aname.name;
        }
        return colorspace;
      });
    }
  }, {
    key: "get",
    value: function get(_ref2) {
      var cs = _ref2.cs,
        xref = _ref2.xref,
        resources = _ref2.resources,
        pdfManager = _ref2.pdfManager,
        local = _ref2.local;
      if (!cs) {
        return Promise.resolve(this.singletons.gray);
      }
      if ((0, _primitives.isName)(cs)) {
        var name = cs.name;
        if (this.cache.has(name)) {
          return this.cache.get(name);
        }
        var promise = this.parseAsync({
          cs: name,
          xref: xref,
          resources: resources,
          pdfManager: pdfManager,
          local: local
        });
        this.cache.set(name, promise);
        return promise;
      }
      if (Array.isArray(cs)) {
        return this.parseAsync({
          cs: cs,
          xref: xref,
          resources: resources,
          pdfManager: pdfManager,
          local: local
        });
      }
      (0, _util.warn)("Unimplemented color space object: ".concat(cs));
      return Promise.resolve(this.singletons.gray);
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.cache = new Map();
    }
  }, {
    key: "singletons",
    get: function get() {
      return (0, _util.shadow)(this, "singletons", {
        get gray() {
          return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
        },
        get rgb() {
          return (0, _util.shadow)(this, "rgb", new DeviceRGBCS());
        },
        get cmyk() {
          return (0, _util.shadow)(this, "cmyk", new DeviceCMYKCS());
        }
      });
    }
  }]);
  return ColorSpace;
}();
exports.ColorSpace = ColorSpace;
ColorSpace.cache = new Map();
var DeviceGrayCS = function () {
  function DeviceGrayCS() {
    _classCallCheck(this, DeviceGrayCS);
    this.name = "DeviceGray";
    this.numComps = 1;
  }
  _createClass(DeviceGrayCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      var c = src[srcOffset];
      return [c, c, c];
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      var c = src[srcOffset];
      dest[destOffset] = c;
      dest[destOffset + 1] = c;
      dest[destOffset + 2] = c;
    }
  }, {
    key: "getOutputLength",
    value: function getOutputLength(inputLength, alpha) {
      return inputLength * 3;
    }
  }]);
  return DeviceGrayCS;
}();
var DeviceRGBCS = function () {
  function DeviceRGBCS() {
    _classCallCheck(this, DeviceRGBCS);
    this.name = "DeviceRGB";
    this.numComps = 3;
  }
  _createClass(DeviceRGBCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      return [src[srcOffset], src[srcOffset + 1], src[srcOffset + 2]];
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      dest[destOffset] = src[srcOffset];
      dest[destOffset + 1] = src[srcOffset + 1];
      dest[destOffset + 2] = src[srcOffset + 2];
    }
  }, {
    key: "getOutputLength",
    value: function getOutputLength(inputLength, alpha) {
      return inputLength;
    }
  }]);
  return DeviceRGBCS;
}();
var DeviceCMYKCS = function () {
  function DeviceCMYKCS() {
    _classCallCheck(this, DeviceCMYKCS);
    this.name = "DeviceCMYK";
    this.numComps = 4;
  }
  _createClass(DeviceCMYKCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      var c = src[srcOffset];
      var m = src[srcOffset + 1];
      var y = src[srcOffset + 2];
      var k = src[srcOffset + 3];
      return [255 * (1 - c / 255) * (1 - k / 255), 255 * (1 - m / 255) * (1 - k / 255), 255 * (1 - y / 255) * (1 - k / 255)];
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      var c = src[srcOffset];
      var m = src[srcOffset + 1];
      var y = src[srcOffset + 2];
      var k = src[srcOffset + 3];
      dest[destOffset] = 255 * (1 - c / 255) * (1 - k / 255);
      dest[destOffset + 1] = 255 * (1 - m / 255) * (1 - k / 255);
      dest[destOffset + 2] = 255 * (1 - y / 255) * (1 - k / 255);
    }
  }, {
    key: "getOutputLength",
    value: function getOutputLength(inputLength, alpha) {
      return inputLength / 4 * 3;
    }
  }]);
  return DeviceCMYKCS;
}();
var CalGrayCS = function (_DeviceGrayCS) {
  _inherits(CalGrayCS, _DeviceGrayCS);
  var _super = _createSuper(CalGrayCS);
  function CalGrayCS(params, xref) {
    var _this;
    _classCallCheck(this, CalGrayCS);
    _this = _super.call(this);
    _this.name = "CalGray";
    return _this;
  }
  return _createClass(CalGrayCS);
}(DeviceGrayCS);
var CalRGBCS = function (_DeviceRGBCS) {
  _inherits(CalRGBCS, _DeviceRGBCS);
  var _super2 = _createSuper(CalRGBCS);
  function CalRGBCS(params, xref) {
    var _this2;
    _classCallCheck(this, CalRGBCS);
    _this2 = _super2.call(this);
    _this2.name = "CalRGB";
    return _this2;
  }
  return _createClass(CalRGBCS);
}(DeviceRGBCS);
var LabCS = function (_ColorSpace) {
  _inherits(LabCS, _ColorSpace);
  var _super3 = _createSuper(LabCS);
  function LabCS(params, xref) {
    var _this3;
    _classCallCheck(this, LabCS);
    _this3 = _super3.call(this);
    _this3.name = "Lab";
    _this3.numComps = 3;
    return _this3;
  }
  _createClass(LabCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      return [0, 0, 0];
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = 0;
    }
  }]);
  return LabCS;
}(ColorSpace);
var ICCBasedCS = function (_ColorSpace2) {
  _inherits(ICCBasedCS, _ColorSpace2);
  var _super4 = _createSuper(ICCBasedCS);
  function ICCBasedCS(stream, xref, resources) {
    var _this4;
    _classCallCheck(this, ICCBasedCS);
    _this4 = _super4.call(this);
    var dict = stream.dict;
    _this4.numComps = dict.get("N");
    var alt = dict.get("Alternate");
    if (alt) {
      _this4.alt = ColorSpace.parseAsync({
        cs: alt,
        xref: xref,
        resources: resources,
        pdfManager: null,
        local: false
      });
    }
    _this4.name = "ICCBased";
    return _this4;
  }
  _createClass(ICCBasedCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      return [0, 0, 0];
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = 0;
    }
  }]);
  return ICCBasedCS;
}(ColorSpace);
var IndexedCS = function (_ColorSpace3) {
  _inherits(IndexedCS, _ColorSpace3);
  var _super5 = _createSuper(IndexedCS);
  function IndexedCS(base, hival, lookup) {
    var _this5;
    _classCallCheck(this, IndexedCS);
    _this5 = _super5.call(this);
    _this5.base = base;
    _this5.hival = hival;
    _this5.lookup = lookup;
    _this5.name = "Indexed";
    _this5.numComps = 1;
    return _this5;
  }
  _createClass(IndexedCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      var i = src[srcOffset];
      if (i > this.hival) {
        return this.base.getRgb(src, srcOffset);
      }
      var lookup = this.lookup;
      var numComps = this.base.numComps;
      var start = i * numComps;
      var sub = lookup.subarray(start, start + numComps);
      return this.base.getRgb(sub, 0);
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      var i = src[srcOffset];
      if (i > this.hival) {
        this.base.getRgbBuffer(src, srcOffset, dest, destOffset);
        return;
      }
      var lookup = this.lookup;
      var numComps = this.base.numComps;
      var start = i * numComps;
      var sub = lookup.subarray(start, start + numComps);
      this.base.getRgbBuffer(sub, 0, dest, destOffset);
    }
  }, {
    key: "getOutputLength",
    value: function getOutputLength(inputLength, alpha) {
      return this.base.getOutputLength(inputLength, alpha);
    }
  }]);
  return IndexedCS;
}(ColorSpace);
var PatternCS = function (_ColorSpace4) {
  _inherits(PatternCS, _ColorSpace4);
  var _super6 = _createSuper(PatternCS);
  function PatternCS(name, baseCS, pdfManager) {
    var _this6;
    _classCallCheck(this, PatternCS);
    _this6 = _super6.call(this);
    _this6.name = "Pattern";
    _this6.baseCS = baseCS;
    _this6.numComps = baseCS ? baseCS.numComps : 0;
    _this6.pdfManager = pdfManager;
    return _this6;
  }
  _createClass(PatternCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      if (this.baseCS) {
        return this.baseCS.getRgb(src, srcOffset);
      }
      return [0, 0, 0];
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      if (this.baseCS) {
        this.baseCS.getRgbBuffer(src, srcOffset, dest, destOffset);
      } else {
        dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = 0;
      }
    }
  }]);
  return PatternCS;
}(ColorSpace);
var SeparationCS = function (_ColorSpace5) {
  _inherits(SeparationCS, _ColorSpace5);
  var _super7 = _createSuper(SeparationCS);
  function SeparationCS(name, alt, tintFn) {
    var _this7;
    _classCallCheck(this, SeparationCS);
    _this7 = _super7.call(this);
    _this7.name = "Separation";
    _this7.alt = alt;
    _this7.tintFn = tintFn;
    _this7.numComps = 1;
    return _this7;
  }
  _createClass(SeparationCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      var x = src[srcOffset];
      var result = this.tintFn.call(this, [x]);
      return this.alt.getRgb(result, 0);
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      var x = src[srcOffset];
      var result = this.tintFn.call(this, [x]);
      this.alt.getRgbBuffer(result, 0, dest, destOffset);
    }
  }]);
  return SeparationCS;
}(ColorSpace);
var DeviceNCS = function (_ColorSpace6) {
  _inherits(DeviceNCS, _ColorSpace6);
  var _super8 = _createSuper(DeviceNCS);
  function DeviceNCS(names, alt, tintFn, attrs) {
    var _this8;
    _classCallCheck(this, DeviceNCS);
    _this8 = _super8.call(this);
    _this8.names = names;
    _this8.alt = alt;
    _this8.tintFn = tintFn;
    _this8.attrs = attrs;
    _this8.name = "DeviceN";
    _this8.numComps = names.length;
    return _this8;
  }
  _createClass(DeviceNCS, [{
    key: "getRgb",
    value: function getRgb(src, srcOffset) {
      var result = this.tintFn.call(this, src.subarray(srcOffset, srcOffset + this.numComps));
      return this.alt.getRgb(result, 0);
    }
  }, {
    key: "getRgbBuffer",
    value: function getRgbBuffer(src, srcOffset, dest, destOffset) {
      var result = this.tintFn.call(this, src.subarray(srcOffset, srcOffset + this.numComps));
      this.alt.getRgbBuffer(result, 0, dest, destOffset);
    }
  }]);
  return DeviceNCS;
}(ColorSpace);

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Pattern = void 0;
var _util = __webpack_require__(1);
var _primitives = __webpack_require__(6);
var _stream = __webpack_require__(7);
var _colorspace = __webpack_require__(13);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var Pattern = function () {
  function Pattern() {
    _classCallCheck(this, Pattern);
  }
  _createClass(Pattern, null, [{
    key: "parseShading",
    value: function parseShading(shading, matrix, xref, res, pdfManager) {
      var dict = (0, _primitives.isStream)(shading) ? shading.dict : shading;
      var type = dict.get("ShadingType");
      switch (type) {
        case 1:
          return new FunctionShading(shading, matrix, xref, res, pdfManager);
        case 2:
          return new AxialShading(shading, matrix, xref, res, pdfManager);
        case 3:
          return new RadialShading(shading, matrix, xref, res, pdfManager);
        case 4:
        case 5:
        case 6:
        case 7:
          (0, _util.warn)("Unsupported shading type: ".concat(type));
          return new DummyShading();
        default:
          throw new Error("Unknown shading type: ".concat(type));
      }
    }
  }]);
  return Pattern;
}();
exports.Pattern = Pattern;
var Shading = function () {
  function Shading(shading, matrix, xref, res, pdfManager) {
    _classCallCheck(this, Shading);
    this.shading = shading;
    this.matrix = matrix;
    this.xref = xref;
    this.res = res;
    this.pdfManager = pdfManager;
  }
  _createClass(Shading, [{
    key: "getIR",
    value: function getIR() {
      throw new Error("Should not call Shading.getIR");
    }
  }]);
  return Shading;
}();
var FunctionShading = function (_Shading) {
  _inherits(FunctionShading, _Shading);
  var _super = _createSuper(FunctionShading);
  function FunctionShading() {
    _classCallCheck(this, FunctionShading);
    return _super.apply(this, arguments);
  }
  _createClass(FunctionShading, [{
    key: "getIR",
    value: function getIR() {
      return ["Dummy"];
    }
  }]);
  return FunctionShading;
}(Shading);
var AxialShading = function (_Shading2) {
  _inherits(AxialShading, _Shading2);
  var _super2 = _createSuper(AxialShading);
  function AxialShading() {
    _classCallCheck(this, AxialShading);
    return _super2.apply(this, arguments);
  }
  _createClass(AxialShading, [{
    key: "getIR",
    value: function getIR() {
      var dict = (0, _primitives.isStream)(this.shading) ? this.shading.dict : this.shading;
      var coords = dict.get("Coords");
      var t0 = dict.get("Domain")[0];
      var t1 = dict.get("Domain")[1];
      var colorStops = [];
      var fn = this.pdfManager.parseNF(dict.get("Function"))[0];
      var step = (t1 - t0) / 10;
      for (var i = 0; i <= 10; i++) {
        var t = t0 + i * step;
        var color = fn([t]);
        colorStops.push({
          offset: (t - t0) / (t1 - t0),
          color: "rgb(" + Math.round(color[0] * 255) + "," + Math.round(color[1] * 255) + "," + Math.round(color[2] * 255) + ")"
        });
      }
      return ["Axial", this.shading.objId, coords, colorStops];
    }
  }]);
  return AxialShading;
}(Shading);
var RadialShading = function (_Shading3) {
  _inherits(RadialShading, _Shading3);
  var _super3 = _createSuper(RadialShading);
  function RadialShading() {
    _classCallCheck(this, RadialShading);
    return _super3.apply(this, arguments);
  }
  _createClass(RadialShading, [{
    key: "getIR",
    value: function getIR() {
      var dict = (0, _primitives.isStream)(this.shading) ? this.shading.dict : this.shading;
      var coords = dict.get("Coords");
      var t0 = dict.get("Domain")[0];
      var t1 = dict.get("Domain")[1];
      var colorStops = [];
      var fn = this.pdfManager.parseNF(dict.get("Function"))[0];
      var step = (t1 - t0) / 10;
      for (var i = 0; i <= 10; i++) {
        var t = t0 + i * step;
        var color = fn([t]);
        colorStops.push({
          offset: (t - t0) / (t1 - t0),
          color: "rgb(" + Math.round(color[0] * 255) + "," + Math.round(color[1] * 255) + "," + Math.round(color[2] * 255) + ")"
        });
      }
      return ["Radial", this.shading.objId, coords, colorStops];
    }
  }]);
  return RadialShading;
}(Shading);
var DummyShading = function () {
  function DummyShading() {
    _classCallCheck(this, DummyShading);
  }
  _createClass(DummyShading, [{
    key: "getIR",
    value: function getIR() {
      return ["Dummy"];
    }
  }]);
  return DummyShading;
}();

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ImageUtils = void 0;
var _util = __webpack_require__(1);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var ImageUtils = function () {
  function ImageUtils() {
    _classCallCheck(this, ImageUtils);
  }
  _createClass(ImageUtils, null, [{
    key: "getImageData",
    value: function getImageData(image) {
      var width = image.width,
        height = image.height,
        data = image.data;
      var kind = image.kind,
        numComps = image.numComps,
        bpc = image.bpc;
      if (kind === _util.ImageKind.GRAYSCALE_1BPP) {
        var bytes = new Uint8ClampedArray(width * height * 4);
        var i = 0,
          j = 0;
        var mask = 0x80;
        for (var y = 0; y < height; y++) {
          for (var x = 0; x < width; x++) {
            var bit = data[i] & mask;
            var gray = bit ? 0 : 255;
            bytes[j] = bytes[j + 1] = bytes[j + 2] = gray;
            bytes[j + 3] = 255;
            j += 4;
            mask >>= 1;
            if (mask === 0) {
              i++;
              mask = 0x80;
            }
          }
        }
        return {
          width: width,
          height: height,
          kind: _util.ImageKind.RGBA_32BPP,
          data: bytes
        };
      }
      if (kind === _util.ImageKind.RGB_24BPP && numComps === 3 && bpc === 8) {
        var _bytes = new Uint8ClampedArray(width * height * 4);
        var _i = 0,
          _j = 0;
        for (var _y = 0; _y < height; _y++) {
          for (var _x = 0; _x < width; _x++) {
            _bytes[_j] = data[_i];
            _bytes[_j + 1] = data[_i + 1];
            _bytes[_j + 2] = data[_i + 2];
            _bytes[_j + 3] = 255;
            _i += 3;
            _j += 4;
          }
        }
        return {
          width: width,
          height: height,
          kind: _util.ImageKind.RGBA_32BPP,
          data: _bytes
        };
      }
      return image;
    }
  }]);
  return ImageUtils;
}();
exports.ImageUtils = ImageUtils;

/***/ }),
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  WorkerMessageHandler: true,
  initializeWorker: true
};
Object.defineProperty(exports, "WorkerMessageHandler", ({
  enumerable: true,
  get: function get() {
    return _worker.WorkerMessageHandler;
  }
}));
exports.initializeWorker = initializeWorker;
var _util = __webpack_require__(1);
Object.keys(_util).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _util[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _util[key];
    }
  });
});
var _worker = __webpack_require__(2);
function initializeWorker() {
  (0, _worker.initializeWorker)();
}

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.md5 = void 0;
var md5 = function () {
  var md5 = function md5(message, options) {
    if (message.constructor === String) {
      message = utf8Encode(message);
    } else if (message.constructor === ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476];
    var K = [0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391];
    var T = function T(x) {
      return x;
    };
    var FF = function FF(a, b, c, d, x, s, k) {
      return T((a << s | a >>> 32 - s) + b) + (b & c | ~b & d) + x + k;
    };
    var GG = function GG(a, b, c, d, x, s, k) {
      return T((a << s | a >>> 32 - s) + b) + (b & d | c & ~d) + x + k;
    };
    var HH = function HH(a, b, c, d, x, s, k) {
      return T((a << s | a >>> 32 - s) + b) + (b ^ c ^ d) + x + k;
    };
    var II = function II(a, b, c, d, x, s, k) {
      return T((a << s | a >>> 32 - s) + b) + (c ^ (b | ~d)) + x + k;
    };
    var blocks = message.length * 8;
    var padding = new Uint8Array(blocks + 64 >>> 9 << 4);
    padding.set(message);
    padding[message.length] = 0x80;
    padding = new Uint32Array(padding.buffer);
    padding[padding.length - 2] = blocks & 0xFFFFFFFF;
    padding[padding.length - 1] = blocks / 0x100000000;
    for (var i = 0; i < padding.length; i += 16) {
      var a = H[0],
        b = H[1],
        c = H[2],
        d = H[3];
      a = FF(a, b, c, d, padding[i + 0], 7, K[0]);
      d = FF(d, a, b, c, padding[i + 1], 12, K[1]);
      c = FF(c, d, a, b, padding[i + 2], 17, K[2]);
      b = FF(b, c, d, a, padding[i + 3], 22, K[3]);
      a = FF(a, b, c, d, padding[i + 4], 7, K[4]);
      d = FF(d, a, b, c, padding[i + 5], 12, K[5]);
      c = FF(c, d, a, b, padding[i + 6], 17, K[6]);
      b = FF(b, c, d, a, padding[i + 7], 22, K[7]);
      a = FF(a, b, c, d, padding[i + 8], 7, K[8]);
      d = FF(d, a, b, c, padding[i + 9], 12, K[9]);
      c = FF(c, d, a, b, padding[i + 10], 17, K[10]);
      b = FF(b, c, d, a, padding[i + 11], 22, K[11]);
      a = FF(a, b, c, d, padding[i + 12], 7, K[12]);
      d = FF(d, a, b, c, padding[i + 13], 12, K[13]);
      c = FF(c, d, a, b, padding[i + 14], 17, K[14]);
      b = FF(b, c, d, a, padding[i + 15], 22, K[15]);
      a = GG(a, b, c, d, padding[i + 1], 5, K[16]);
      d = GG(d, a, b, c, padding[i + 6], 9, K[17]);
      c = GG(c, d, a, b, padding[i + 11], 14, K[18]);
      b = GG(b, c, d, a, padding[i + 0], 20, K[19]);
      a = GG(a, b, c, d, padding[i + 5], 5, K[20]);
      d = GG(d, a, b, c, padding[i + 10], 9, K[21]);
      c = GG(c, d, a, b, padding[i + 15], 14, K[22]);
      b = GG(b, c, d, a, padding[i + 4], 20, K[23]);
      a = GG(a, b, c, d, padding[i + 9], 5, K[24]);
      d = GG(d, a, b, c, padding[i + 14], 9, K[25]);
      c = GG(c, d, a, b, padding[i + 3], 14, K[26]);
      b = GG(b, c, d, a, padding[i + 8], 20, K[27]);
      a = GG(a, b, c, d, padding[i + 13], 5, K[28]);
      d = GG(d, a, b, c, padding[i + 2], 9, K[29]);
      c = GG(c, d, a, b, padding[i + 7], 14, K[30]);
      b = GG(b, c, d, a, padding[i + 12], 20, K[31]);
      a = HH(a, b, c, d, padding[i + 5], 4, K[32]);
      d = HH(d, a, b, c, padding[i + 8], 11, K[33]);
      c = HH(c, d, a, b, padding[i + 11], 16, K[34]);
      b = HH(b, c, d, a, padding[i + 14], 23, K[35]);
      a = HH(a, b, c, d, padding[i + 1], 4, K[36]);
      d = HH(d, a, b, c, padding[i + 4], 11, K[37]);
      c = HH(c, d, a, b, padding[i + 7], 16, K[38]);
      b = HH(b, c, d, a, padding[i + 10], 23, K[39]);
      a = HH(a, b, c, d, padding[i + 13], 4, K[40]);
      d = HH(d, a, b, c, padding[i + 0], 11, K[41]);
      c = HH(c, d, a, b, padding[i + 3], 16, K[42]);
      b = HH(b, c, d, a, padding[i + 6], 23, K[43]);
      a = HH(a, b, c, d, padding[i + 9], 4, K[44]);
      d = HH(d, a, b, c, padding[i + 12], 11, K[45]);
      c = HH(c, d, a, b, padding[i + 15], 16, K[46]);
      b = HH(b, c, d, a, padding[i + 2], 23, K[47]);
      a = II(a, b, c, d, padding[i + 0], 6, K[48]);
      d = II(d, a, b, c, padding[i + 7], 10, K[49]);
      c = II(c, d, a, b, padding[i + 14], 15, K[50]);
      b = II(b, c, d, a, padding[i + 5], 21, K[51]);
      a = II(a, b, c, d, padding[i + 12], 6, K[52]);
      d = II(d, a, b, c, padding[i + 3], 10, K[53]);
      c = II(c, d, a, b, padding[i + 10], 15, K[54]);
      b = II(b, c, d, a, padding[i + 1], 21, K[55]);
      a = II(a, b, c, d, padding[i + 8], 6, K[56]);
      d = II(d, a, b, c, padding[i + 15], 10, K[57]);
      c = II(c, d, a, b, padding[i + 6], 15, K[58]);
      b = II(b, c, d, a, padding[i + 13], 21, K[59]);
      a = II(a, b, c, d, padding[i + 4], 6, K[60]);
      d = II(d, a, b, c, padding[i + 11], 10, K[61]);
      c = II(c, d, a, b, padding[i + 2], 15, K[62]);
      b = II(b, c, d, a, padding[i + 9], 21, K[63]);
      H[0] = T(H[0] + a);
      H[1] = T(H[1] + b);
      H[2] = T(H[2] + c);
      H[3] = T(H[3] + d);
    }
    if (options && options.asBytes) {
      var bytes = new Uint8Array(16);
      var buffer = new Uint32Array(bytes.buffer);
      for (var _i = 0; _i < 4; _i++) {
        buffer[_i] = H[_i];
      }
      return bytes;
    }
    if (options && options.asString) {
      return hex(H);
    }
    return hex(H);
  };
  function utf8Encode(str) {
    var bytes = [];
    for (var i = 0; i < str.length; i++) {
      var code = str.charCodeAt(i);
      if (code < 0x80) {
        bytes.push(code);
      } else if (code < 0x800) {
        bytes.push(0xC0 | code >> 6, 0x80 | code & 0x3F);
      } else if (code < 0xD800 || code >= 0xE000) {
        bytes.push(0xE0 | code >> 12, 0x80 | code >> 6 & 0x3F, 0x80 | code & 0x3F);
      } else {
        code = 0x10000 + ((code & 0x3FF) << 10 | str.charCodeAt(++i) & 0x3FF);
        bytes.push(0xF0 | code >> 18, 0x80 | code >> 12 & 0x3F, 0x80 | code >> 6 & 0x3F, 0x80 | code & 0x3F);
      }
    }
    return bytes;
  }
  function hex(x) {
    var a = [],
      i;
    for (i = 0; i < x.length; i++) {
      a.push((x[i] >>> 4).toString(16));
      a.push((x[i] & 0xF).toString(16));
    }
    return a.join("");
  }
  return md5;
}();
exports.md5 = md5;

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFWorker = void 0;
var _pdfjs = __webpack_require__(19);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var PDFWorker = function (_PDFJSWorker) {
  _inherits(PDFWorker, _PDFJSWorker);
  var _super = _createSuper(PDFWorker);
  function PDFWorker(name, port) {
    var _this;
    _classCallCheck(this, PDFWorker);
    _this = _super.call(this);
    _this.name = name;
    _this.port = port;
    _this.messageHandler = new _pdfjs.WorkerMessageHandler(_assertThisInitialized(_this));
    return _this;
  }
  return _createClass(PDFWorker);
}(_pdfjs.PDFWorker);
exports.PDFWorker = PDFWorker;
(0, _pdfjs.initializeWorker)();
})();

/******/ })()
;
//# sourceMappingURL=pdf.worker.min.js.map
